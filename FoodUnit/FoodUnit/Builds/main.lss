
Builds/main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000086  00800100  00002306  0000239a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002306  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000b  00800186  00800186  00002420  2**0
                  ALLOC
  3 .stab         000040d4  00000000  00000000  00002420  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000212e  00000000  00000000  000064f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00008622  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000000a0  00000000  00000000  00008638  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000003bb  00000000  00000000  000086d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000064  00000000  00000000  00008a93  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001ec  00000000  00000000  00008af7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 aa 00 	jmp	0x154	; 0x154 <__ctors_end>
       4:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
       8:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
       c:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      10:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      14:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      18:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      1c:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      20:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      24:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      28:	0c 94 ac 0c 	jmp	0x1958	; 0x1958 <__vector_10>
      2c:	0c 94 eb 0c 	jmp	0x19d6	; 0x19d6 <__vector_11>
      30:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      34:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      38:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      3c:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      40:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      44:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      48:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      4c:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      50:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      54:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      58:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      5c:	0c 94 92 03 	jmp	0x724	; 0x724 <__vector_23>
      60:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      64:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      68:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      6c:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      70:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      74:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      78:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      7c:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      80:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      84:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      88:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      8c:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      90:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>
      94:	0c 94 c9 00 	jmp	0x192	; 0x192 <__bad_interrupt>

00000098 <__trampolines_end>:
      98:	00 01       	movw	r0, r0
      9a:	00 00       	nop
      9c:	3c 01       	movw	r6, r24
      9e:	12 00       	.word	0x0012	; ????
      a0:	02 00       	.word	0x0002	; ????
      a2:	00 05       	cpc	r16, r0
      a4:	01 22       	and	r0, r17
      a6:	00 22       	and	r0, r16
      a8:	00 00       	nop
      aa:	27 01       	movw	r4, r14
      ac:	15 00       	.word	0x0015	; ????
      ae:	21 00       	.word	0x0021	; ????
      b0:	00 17       	cp	r16, r16
      b2:	01 09       	sbc	r16, r1
      b4:	00 03       	mulsu	r16, r16
      b6:	00 00       	nop
      b8:	01 01       	movw	r0, r2
      ba:	04 01       	movw	r0, r8
      bc:	03 09       	sbc	r16, r3
      be:	04 eb       	ldi	r16, 0xB4	; 180
      c0:	00 14       	cp	r0, r0
      c2:	02 03       	mulsu	r16, r18
      c4:	09 04       	cpc	r0, r9
      c6:	c9 00       	.word	0x00c9	; ????
      c8:	20 20       	and	r2, r0

000000c9 <string2>:
      c9:	20 03 59 00 6f 00 75 00 72 00 20 00 55 00 53 00      .Y.o.u.r. .U.S.
      d9:	42 00 20 00 44 00 65 00 76 00 69 00 63 00 65 00     B. .D.e.v.i.c.e.
	...

000000eb <string1>:
      eb:	14 03 59 00 6f 00 75 00 72 00 20 00 4e 00 61 00     ..Y.o.u.r. .N.a.
      fb:	6d 00 65 00 00 00                                   m.e...

00000101 <string0>:
     101:	04 03 09 04                                         ....

00000105 <config1_descriptor>:
     105:	09 02 22 00 01 01 00 c0 32 09 04 00 00 01 03 00     ..".....2.......
     115:	00 00 09 21 11 01 00 01 22 15 00 07 05 83 03 20     ...!...."...... 
     125:	00 01                                               ..

00000127 <hid_report_descriptor>:
     127:	06 31 ff 09 74 a1 53 75 08 15 00 26 ff 00 95 20     .1..t.Su...&... 
     137:	09 75 81 02 c0                                      .u...

0000013c <device_descriptor>:
     13c:	12 01 00 02 00 00 00 20 c0 16 79 04 00 01 01 02     ....... ..y.....
     14c:	00 01                                               ..

0000014e <endpoint_config_table>:
     14e:	00 00 01 c1 26 00                                   ....&.

00000154 <__ctors_end>:
     154:	11 24       	eor	r1, r1
     156:	1f be       	out	0x3f, r1	; 63
     158:	cf ef       	ldi	r28, 0xFF	; 255
     15a:	d0 e2       	ldi	r29, 0x20	; 32
     15c:	de bf       	out	0x3e, r29	; 62
     15e:	cd bf       	out	0x3d, r28	; 61

00000160 <__do_copy_data>:
     160:	11 e0       	ldi	r17, 0x01	; 1
     162:	a0 e0       	ldi	r26, 0x00	; 0
     164:	b1 e0       	ldi	r27, 0x01	; 1
     166:	e6 e0       	ldi	r30, 0x06	; 6
     168:	f3 e2       	ldi	r31, 0x23	; 35
     16a:	00 e0       	ldi	r16, 0x00	; 0
     16c:	0b bf       	out	0x3b, r16	; 59
     16e:	02 c0       	rjmp	.+4      	; 0x174 <__do_copy_data+0x14>
     170:	07 90       	elpm	r0, Z+
     172:	0d 92       	st	X+, r0
     174:	a6 38       	cpi	r26, 0x86	; 134
     176:	b1 07       	cpc	r27, r17
     178:	d9 f7       	brne	.-10     	; 0x170 <__do_copy_data+0x10>

0000017a <__do_clear_bss>:
     17a:	21 e0       	ldi	r18, 0x01	; 1
     17c:	a6 e8       	ldi	r26, 0x86	; 134
     17e:	b1 e0       	ldi	r27, 0x01	; 1
     180:	01 c0       	rjmp	.+2      	; 0x184 <.do_clear_bss_start>

00000182 <.do_clear_bss_loop>:
     182:	1d 92       	st	X+, r1

00000184 <.do_clear_bss_start>:
     184:	a1 39       	cpi	r26, 0x91	; 145
     186:	b2 07       	cpc	r27, r18
     188:	e1 f7       	brne	.-8      	; 0x182 <.do_clear_bss_loop>
     18a:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <main>
     18e:	0c 94 81 11 	jmp	0x2302	; 0x2302 <_exit>

00000192 <__bad_interrupt>:
     192:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000196 <time_is_greater>:
    uint16_t hours;
} time;

#define TIME_ZERO time_make(0,0,0,0)

bool time_is_greater(time a, time b) {
     196:	af 92       	push	r10
     198:	bf 92       	push	r11
     19a:	cf 92       	push	r12
     19c:	df 92       	push	r13
     19e:	ef 92       	push	r14
     1a0:	ff 92       	push	r15
     1a2:	0f 93       	push	r16
     1a4:	1f 93       	push	r17
     1a6:	cf 93       	push	r28
     1a8:	df 93       	push	r29
     1aa:	cd b7       	in	r28, 0x3d	; 61
     1ac:	de b7       	in	r29, 0x3e	; 62
     1ae:	60 97       	sbiw	r28, 0x10	; 16
     1b0:	0f b6       	in	r0, 0x3f	; 63
     1b2:	f8 94       	cli
     1b4:	de bf       	out	0x3e, r29	; 62
     1b6:	0f be       	out	0x3f, r0	; 63
     1b8:	cd bf       	out	0x3d, r28	; 61
     1ba:	29 83       	std	Y+1, r18	; 0x01
     1bc:	3a 83       	std	Y+2, r19	; 0x02
     1be:	4b 83       	std	Y+3, r20	; 0x03
     1c0:	5c 83       	std	Y+4, r21	; 0x04
     1c2:	6d 83       	std	Y+5, r22	; 0x05
     1c4:	7e 83       	std	Y+6, r23	; 0x06
     1c6:	8f 83       	std	Y+7, r24	; 0x07
     1c8:	98 87       	std	Y+8, r25	; 0x08
     1ca:	a9 86       	std	Y+9, r10	; 0x09
     1cc:	ba 86       	std	Y+10, r11	; 0x0a
     1ce:	cb 86       	std	Y+11, r12	; 0x0b
     1d0:	dc 86       	std	Y+12, r13	; 0x0c
     1d2:	ed 86       	std	Y+13, r14	; 0x0d
     1d4:	fe 86       	std	Y+14, r15	; 0x0e
     1d6:	0f 87       	std	Y+15, r16	; 0x0f
     1d8:	18 8b       	std	Y+16, r17	; 0x10
     1da:	2b 81       	ldd	r18, Y+3	; 0x03
     1dc:	3c 81       	ldd	r19, Y+4	; 0x04
     1de:	6d 81       	ldd	r22, Y+5	; 0x05
     1e0:	7e 81       	ldd	r23, Y+6	; 0x06
     1e2:	af 81       	ldd	r26, Y+7	; 0x07
     1e4:	b8 85       	ldd	r27, Y+8	; 0x08
     1e6:	8b 85       	ldd	r24, Y+11	; 0x0b
     1e8:	9c 85       	ldd	r25, Y+12	; 0x0c
     1ea:	4d 85       	ldd	r20, Y+13	; 0x0d
     1ec:	5e 85       	ldd	r21, Y+14	; 0x0e
     1ee:	ef 85       	ldd	r30, Y+15	; 0x0f
     1f0:	f8 89       	ldd	r31, Y+16	; 0x10
    if (a.hours > b.hours) {
     1f2:	ea 17       	cp	r30, r26
     1f4:	fb 07       	cpc	r31, r27
     1f6:	c0 f0       	brcs	.+48     	; 0x228 <time_is_greater+0x92>
        return true;
    }
    if (a.hours < b.hours) {
     1f8:	ae 17       	cp	r26, r30
     1fa:	bf 07       	cpc	r27, r31
     1fc:	b8 f0       	brcs	.+46     	; 0x22c <time_is_greater+0x96>
        return false;
    }
   
    if (a.seconds > b.seconds) {
     1fe:	46 17       	cp	r20, r22
     200:	57 07       	cpc	r21, r23
     202:	90 f0       	brcs	.+36     	; 0x228 <time_is_greater+0x92>
        return true;
    }
    if (a.seconds < b.seconds) {
     204:	64 17       	cp	r22, r20
     206:	75 07       	cpc	r23, r21
     208:	88 f0       	brcs	.+34     	; 0x22c <time_is_greater+0x96>
        return false;
    }
    
    if (a.millis > b.millis) {
     20a:	82 17       	cp	r24, r18
     20c:	93 07       	cpc	r25, r19
     20e:	60 f0       	brcs	.+24     	; 0x228 <time_is_greater+0x92>
        return true;
    }
    if (a.millis < b.millis) {
     210:	28 17       	cp	r18, r24
     212:	39 07       	cpc	r19, r25
     214:	58 f0       	brcs	.+22     	; 0x22c <time_is_greater+0x96>
        return false;
    }
    
    if (a.clock > b.clock) {
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	49 81       	ldd	r20, Y+1	; 0x01
     21a:	5a 81       	ldd	r21, Y+2	; 0x02
     21c:	29 85       	ldd	r18, Y+9	; 0x09
     21e:	3a 85       	ldd	r19, Y+10	; 0x0a
     220:	24 17       	cp	r18, r20
     222:	35 07       	cpc	r19, r21
     224:	20 f0       	brcs	.+8      	; 0x22e <time_is_greater+0x98>
     226:	02 c0       	rjmp	.+4      	; 0x22c <time_is_greater+0x96>

#define TIME_ZERO time_make(0,0,0,0)

bool time_is_greater(time a, time b) {
    if (a.hours > b.hours) {
        return true;
     228:	81 e0       	ldi	r24, 0x01	; 1
     22a:	01 c0       	rjmp	.+2      	; 0x22e <time_is_greater+0x98>
    }
    if (a.hours < b.hours) {
        return false;
     22c:	80 e0       	ldi	r24, 0x00	; 0
    
    if (a.clock > b.clock) {
        return true;
    }
    return false;
}
     22e:	60 96       	adiw	r28, 0x10	; 16
     230:	0f b6       	in	r0, 0x3f	; 63
     232:	f8 94       	cli
     234:	de bf       	out	0x3e, r29	; 62
     236:	0f be       	out	0x3f, r0	; 63
     238:	cd bf       	out	0x3d, r28	; 61
     23a:	df 91       	pop	r29
     23c:	cf 91       	pop	r28
     23e:	1f 91       	pop	r17
     240:	0f 91       	pop	r16
     242:	ff 90       	pop	r15
     244:	ef 90       	pop	r14
     246:	df 90       	pop	r13
     248:	cf 90       	pop	r12
     24a:	bf 90       	pop	r11
     24c:	af 90       	pop	r10
     24e:	08 95       	ret

00000250 <time_update>:

time time_update(time t, uint16_t clks) {
     250:	0f 93       	push	r16
     252:	1f 93       	push	r17
     254:	cf 93       	push	r28
     256:	df 93       	push	r29
     258:	cd b7       	in	r28, 0x3d	; 61
     25a:	de b7       	in	r29, 0x3e	; 62
     25c:	60 97       	sbiw	r28, 0x10	; 16
     25e:	0f b6       	in	r0, 0x3f	; 63
     260:	f8 94       	cli
     262:	de bf       	out	0x3e, r29	; 62
     264:	0f be       	out	0x3f, r0	; 63
     266:	cd bf       	out	0x3d, r28	; 61
     268:	29 87       	std	Y+9, r18	; 0x09
     26a:	3a 87       	std	Y+10, r19	; 0x0a
     26c:	4b 87       	std	Y+11, r20	; 0x0b
     26e:	5c 87       	std	Y+12, r21	; 0x0c
     270:	6d 87       	std	Y+13, r22	; 0x0d
     272:	7e 87       	std	Y+14, r23	; 0x0e
     274:	8f 87       	std	Y+15, r24	; 0x0f
     276:	98 8b       	std	Y+16, r25	; 0x10
     278:	49 85       	ldd	r20, Y+9	; 0x09
     27a:	5a 85       	ldd	r21, Y+10	; 0x0a
     27c:	2b 85       	ldd	r18, Y+11	; 0x0b
     27e:	3c 85       	ldd	r19, Y+12	; 0x0c
     280:	6d 85       	ldd	r22, Y+13	; 0x0d
     282:	7e 85       	ldd	r23, Y+14	; 0x0e
     284:	8f 85       	ldd	r24, Y+15	; 0x0f
     286:	98 89       	ldd	r25, Y+16	; 0x10
    t.clock += clks;
     288:	04 0f       	add	r16, r20
     28a:	15 1f       	adc	r17, r21
    if (t.clock >= (F_CPU / 1000)) {
     28c:	00 38       	cpi	r16, 0x80	; 128
     28e:	4e e3       	ldi	r20, 0x3E	; 62
     290:	14 07       	cpc	r17, r20
     292:	b0 f0       	brcs	.+44     	; 0x2c0 <time_update+0x70>
        t.millis++;
     294:	a9 01       	movw	r20, r18
     296:	4f 5f       	subi	r20, 0xFF	; 255
     298:	5f 4f       	sbci	r21, 0xFF	; 255
        t.clock -= (F_CPU / 1000);
     29a:	00 58       	subi	r16, 0x80	; 128
     29c:	1e 43       	sbci	r17, 0x3E	; 62
        if (t.millis >= 1000) {
     29e:	48 3e       	cpi	r20, 0xE8	; 232
     2a0:	e3 e0       	ldi	r30, 0x03	; 3
     2a2:	5e 07       	cpc	r21, r30
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <time_update+0x76>
            t.millis -= 1000;
     2a6:	48 5e       	subi	r20, 0xE8	; 232
     2a8:	53 40       	sbci	r21, 0x03	; 3
            t.seconds++;
     2aa:	9b 01       	movw	r18, r22
     2ac:	2f 5f       	subi	r18, 0xFF	; 255
     2ae:	3f 4f       	sbci	r19, 0xFF	; 255
            if (t.seconds >= 3600) {
     2b0:	20 31       	cpi	r18, 0x10	; 16
     2b2:	ee e0       	ldi	r30, 0x0E	; 14
     2b4:	3e 07       	cpc	r19, r30
     2b6:	30 f0       	brcs	.+12     	; 0x2c4 <time_update+0x74>
                t.seconds -= 3600;
     2b8:	6f 50       	subi	r22, 0x0F	; 15
     2ba:	7e 40       	sbci	r23, 0x0E	; 14
                t.hours++;
     2bc:	01 96       	adiw	r24, 0x01	; 1
     2be:	03 c0       	rjmp	.+6      	; 0x2c6 <time_update+0x76>
     2c0:	a9 01       	movw	r20, r18
     2c2:	01 c0       	rjmp	.+2      	; 0x2c6 <time_update+0x76>
     2c4:	b9 01       	movw	r22, r18
            }
        }
    }
    return t;
     2c6:	1a 83       	std	Y+2, r17	; 0x02
     2c8:	09 83       	std	Y+1, r16	; 0x01
     2ca:	5c 83       	std	Y+4, r21	; 0x04
     2cc:	4b 83       	std	Y+3, r20	; 0x03
     2ce:	7e 83       	std	Y+6, r23	; 0x06
     2d0:	6d 83       	std	Y+5, r22	; 0x05
     2d2:	98 87       	std	Y+8, r25	; 0x08
     2d4:	8f 83       	std	Y+7, r24	; 0x07
     2d6:	20 2f       	mov	r18, r16
     2d8:	3a 81       	ldd	r19, Y+2	; 0x02
     2da:	5c 81       	ldd	r21, Y+4	; 0x04
     2dc:	7e 81       	ldd	r23, Y+6	; 0x06
}
     2de:	98 85       	ldd	r25, Y+8	; 0x08
     2e0:	60 96       	adiw	r28, 0x10	; 16
     2e2:	0f b6       	in	r0, 0x3f	; 63
     2e4:	f8 94       	cli
     2e6:	de bf       	out	0x3e, r29	; 62
     2e8:	0f be       	out	0x3f, r0	; 63
     2ea:	cd bf       	out	0x3d, r28	; 61
     2ec:	df 91       	pop	r29
     2ee:	cf 91       	pop	r28
     2f0:	1f 91       	pop	r17
     2f2:	0f 91       	pop	r16
     2f4:	08 95       	ret

000002f6 <time_make>:

time time_make(uint16_t clk, uint16_t ms, uint16_t s, uint16_t h) {
     2f6:	0f 93       	push	r16
     2f8:	1f 93       	push	r17
     2fa:	cf 93       	push	r28
     2fc:	df 93       	push	r29
     2fe:	cd b7       	in	r28, 0x3d	; 61
     300:	de b7       	in	r29, 0x3e	; 62
     302:	60 97       	sbiw	r28, 0x10	; 16
     304:	0f b6       	in	r0, 0x3f	; 63
     306:	f8 94       	cli
     308:	de bf       	out	0x3e, r29	; 62
     30a:	0f be       	out	0x3f, r0	; 63
     30c:	cd bf       	out	0x3d, r28	; 61
     30e:	e8 2f       	mov	r30, r24
     310:	82 2f       	mov	r24, r18
    time t;
    t.clock = clk;
     312:	2e 2f       	mov	r18, r30
     314:	e9 87       	std	Y+9, r30	; 0x09
     316:	9a 87       	std	Y+10, r25	; 0x0a
    t.millis = ms;
     318:	96 2f       	mov	r25, r22
     31a:	6b 87       	std	Y+11, r22	; 0x0b
     31c:	7c 87       	std	Y+12, r23	; 0x0c
    t.seconds = s;
     31e:	64 2f       	mov	r22, r20
     320:	4d 87       	std	Y+13, r20	; 0x0d
     322:	5e 87       	std	Y+14, r21	; 0x0e
    t.hours = h;
     324:	8f 87       	std	Y+15, r24	; 0x0f
     326:	38 8b       	std	Y+16, r19	; 0x10
    return time_update(t, 0);
     328:	00 e0       	ldi	r16, 0x00	; 0
     32a:	10 e0       	ldi	r17, 0x00	; 0
     32c:	3a 85       	ldd	r19, Y+10	; 0x0a
     32e:	49 2f       	mov	r20, r25
     330:	57 2f       	mov	r21, r23
     332:	7e 85       	ldd	r23, Y+14	; 0x0e
     334:	98 89       	ldd	r25, Y+16	; 0x10
     336:	0e 94 28 01 	call	0x250	; 0x250 <time_update>
}
     33a:	60 96       	adiw	r28, 0x10	; 16
     33c:	0f b6       	in	r0, 0x3f	; 63
     33e:	f8 94       	cli
     340:	de bf       	out	0x3e, r29	; 62
     342:	0f be       	out	0x3f, r0	; 63
     344:	cd bf       	out	0x3d, r28	; 61
     346:	df 91       	pop	r29
     348:	cf 91       	pop	r28
     34a:	1f 91       	pop	r17
     34c:	0f 91       	pop	r16
     34e:	08 95       	ret

00000350 <time_add>:

time time_add(time a, time b) {
     350:	af 92       	push	r10
     352:	bf 92       	push	r11
     354:	cf 92       	push	r12
     356:	df 92       	push	r13
     358:	ef 92       	push	r14
     35a:	ff 92       	push	r15
     35c:	0f 93       	push	r16
     35e:	1f 93       	push	r17
     360:	cf 93       	push	r28
     362:	df 93       	push	r29
     364:	cd b7       	in	r28, 0x3d	; 61
     366:	de b7       	in	r29, 0x3e	; 62
     368:	a8 97       	sbiw	r28, 0x28	; 40
     36a:	0f b6       	in	r0, 0x3f	; 63
     36c:	f8 94       	cli
     36e:	de bf       	out	0x3e, r29	; 62
     370:	0f be       	out	0x3f, r0	; 63
     372:	cd bf       	out	0x3d, r28	; 61
     374:	a9 a2       	std	Y+33, r10	; 0x21
     376:	ba a2       	std	Y+34, r11	; 0x22
     378:	cb a2       	std	Y+35, r12	; 0x23
     37a:	dc a2       	std	Y+36, r13	; 0x24
     37c:	ed a2       	std	Y+37, r14	; 0x25
     37e:	fe a2       	std	Y+38, r15	; 0x26
     380:	0f a3       	std	Y+39, r16	; 0x27
     382:	18 a7       	std	Y+40, r17	; 0x28
    time aa = time_update(a, 0);
     384:	00 e0       	ldi	r16, 0x00	; 0
     386:	10 e0       	ldi	r17, 0x00	; 0
     388:	0e 94 28 01 	call	0x250	; 0x250 <time_update>
     38c:	29 8b       	std	Y+17, r18	; 0x11
     38e:	3a 8b       	std	Y+18, r19	; 0x12
     390:	4b 8b       	std	Y+19, r20	; 0x13
     392:	5c 8b       	std	Y+20, r21	; 0x14
     394:	6d 8b       	std	Y+21, r22	; 0x15
     396:	7e 8b       	std	Y+22, r23	; 0x16
     398:	8f 8b       	std	Y+23, r24	; 0x17
     39a:	98 8f       	std	Y+24, r25	; 0x18
    time bb = time_update(b, 0);
     39c:	29 a1       	ldd	r18, Y+33	; 0x21
     39e:	3a a1       	ldd	r19, Y+34	; 0x22
     3a0:	4b a1       	ldd	r20, Y+35	; 0x23
     3a2:	5c a1       	ldd	r21, Y+36	; 0x24
     3a4:	6d a1       	ldd	r22, Y+37	; 0x25
     3a6:	7e a1       	ldd	r23, Y+38	; 0x26
     3a8:	8f a1       	ldd	r24, Y+39	; 0x27
     3aa:	98 a5       	ldd	r25, Y+40	; 0x28
     3ac:	0e 94 28 01 	call	0x250	; 0x250 <time_update>
     3b0:	29 87       	std	Y+9, r18	; 0x09
     3b2:	3a 87       	std	Y+10, r19	; 0x0a
     3b4:	4b 87       	std	Y+11, r20	; 0x0b
     3b6:	5c 87       	std	Y+12, r21	; 0x0c
     3b8:	6d 87       	std	Y+13, r22	; 0x0d
     3ba:	7e 87       	std	Y+14, r23	; 0x0e
     3bc:	8f 87       	std	Y+15, r24	; 0x0f
     3be:	98 8b       	std	Y+16, r25	; 0x10
    return time_make(aa.clock + bb.clock, aa.millis + bb.millis, aa.seconds + bb.seconds, aa.hours + bb.hours);
     3c0:	2f 85       	ldd	r18, Y+15	; 0x0f
     3c2:	38 89       	ldd	r19, Y+16	; 0x10
     3c4:	8f 89       	ldd	r24, Y+23	; 0x17
     3c6:	98 8d       	ldd	r25, Y+24	; 0x18
     3c8:	28 0f       	add	r18, r24
     3ca:	39 1f       	adc	r19, r25
     3cc:	4d 85       	ldd	r20, Y+13	; 0x0d
     3ce:	5e 85       	ldd	r21, Y+14	; 0x0e
     3d0:	8d 89       	ldd	r24, Y+21	; 0x15
     3d2:	9e 89       	ldd	r25, Y+22	; 0x16
     3d4:	48 0f       	add	r20, r24
     3d6:	59 1f       	adc	r21, r25
     3d8:	6b 85       	ldd	r22, Y+11	; 0x0b
     3da:	7c 85       	ldd	r23, Y+12	; 0x0c
     3dc:	8b 89       	ldd	r24, Y+19	; 0x13
     3de:	9c 89       	ldd	r25, Y+20	; 0x14
     3e0:	68 0f       	add	r22, r24
     3e2:	79 1f       	adc	r23, r25
     3e4:	e9 85       	ldd	r30, Y+9	; 0x09
     3e6:	fa 85       	ldd	r31, Y+10	; 0x0a
     3e8:	89 89       	ldd	r24, Y+17	; 0x11
     3ea:	9a 89       	ldd	r25, Y+18	; 0x12
     3ec:	8e 0f       	add	r24, r30
     3ee:	9f 1f       	adc	r25, r31
     3f0:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <time_make>
}
     3f4:	a8 96       	adiw	r28, 0x28	; 40
     3f6:	0f b6       	in	r0, 0x3f	; 63
     3f8:	f8 94       	cli
     3fa:	de bf       	out	0x3e, r29	; 62
     3fc:	0f be       	out	0x3f, r0	; 63
     3fe:	cd bf       	out	0x3d, r28	; 61
     400:	df 91       	pop	r29
     402:	cf 91       	pop	r28
     404:	1f 91       	pop	r17
     406:	0f 91       	pop	r16
     408:	ff 90       	pop	r15
     40a:	ef 90       	pop	r14
     40c:	df 90       	pop	r13
     40e:	cf 90       	pop	r12
     410:	bf 90       	pop	r11
     412:	af 90       	pop	r10
     414:	08 95       	ret

00000416 <time_diff_internal>:

time time_diff_internal(time a, time b) {
     416:	6f 92       	push	r6
     418:	7f 92       	push	r7
     41a:	8f 92       	push	r8
     41c:	9f 92       	push	r9
     41e:	af 92       	push	r10
     420:	bf 92       	push	r11
     422:	cf 92       	push	r12
     424:	df 92       	push	r13
     426:	ef 92       	push	r14
     428:	ff 92       	push	r15
     42a:	0f 93       	push	r16
     42c:	1f 93       	push	r17
     42e:	cf 93       	push	r28
     430:	df 93       	push	r29
     432:	cd b7       	in	r28, 0x3d	; 61
     434:	de b7       	in	r29, 0x3e	; 62
     436:	a0 97       	sbiw	r28, 0x20	; 32
     438:	0f b6       	in	r0, 0x3f	; 63
     43a:	f8 94       	cli
     43c:	de bf       	out	0x3e, r29	; 62
     43e:	0f be       	out	0x3f, r0	; 63
     440:	cd bf       	out	0x3d, r28	; 61
     442:	e2 2f       	mov	r30, r18
     444:	29 8b       	std	Y+17, r18	; 0x11
     446:	f3 2f       	mov	r31, r19
     448:	3a 8b       	std	Y+18, r19	; 0x12
     44a:	a4 2f       	mov	r26, r20
     44c:	4b 8b       	std	Y+19, r20	; 0x13
     44e:	b5 2f       	mov	r27, r21
     450:	5c 8b       	std	Y+20, r21	; 0x14
     452:	96 2e       	mov	r9, r22
     454:	6d 8b       	std	Y+21, r22	; 0x15
     456:	87 2e       	mov	r8, r23
     458:	7e 8b       	std	Y+22, r23	; 0x16
     45a:	78 2e       	mov	r7, r24
     45c:	8f 8b       	std	Y+23, r24	; 0x17
     45e:	69 2e       	mov	r6, r25
     460:	98 8f       	std	Y+24, r25	; 0x18
     462:	2a 2d       	mov	r18, r10
     464:	a9 8e       	std	Y+25, r10	; 0x19
     466:	3b 2d       	mov	r19, r11
     468:	ba 8e       	std	Y+26, r11	; 0x1a
     46a:	4c 2d       	mov	r20, r12
     46c:	cb 8e       	std	Y+27, r12	; 0x1b
     46e:	5d 2d       	mov	r21, r13
     470:	dc 8e       	std	Y+28, r13	; 0x1c
     472:	6e 2d       	mov	r22, r14
     474:	ed 8e       	std	Y+29, r14	; 0x1d
     476:	7f 2d       	mov	r23, r15
     478:	fe 8e       	std	Y+30, r15	; 0x1e
     47a:	80 2f       	mov	r24, r16
     47c:	0f 8f       	std	Y+31, r16	; 0x1f
     47e:	91 2f       	mov	r25, r17
     480:	18 a3       	std	Y+32, r17	; 0x20
    if (time_is_greater(b, a)) {
     482:	5f 01       	movw	r10, r30
     484:	6d 01       	movw	r12, r26
     486:	e9 2c       	mov	r14, r9
     488:	f8 2c       	mov	r15, r8
     48a:	07 2d       	mov	r16, r7
     48c:	16 2d       	mov	r17, r6
     48e:	0e 94 cb 00 	call	0x196	; 0x196 <time_is_greater>
     492:	88 23       	and	r24, r24
     494:	59 f0       	breq	.+22     	; 0x4ac <time_diff_internal+0x96>
        return TIME_ZERO;
     496:	20 e0       	ldi	r18, 0x00	; 0
     498:	30 e0       	ldi	r19, 0x00	; 0
     49a:	40 e0       	ldi	r20, 0x00	; 0
     49c:	50 e0       	ldi	r21, 0x00	; 0
     49e:	60 e0       	ldi	r22, 0x00	; 0
     4a0:	70 e0       	ldi	r23, 0x00	; 0
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <time_make>
     4aa:	63 c0       	rjmp	.+198    	; 0x572 <time_diff_internal+0x15c>
    }
    
    uint16_t clocka = a.clock;
     4ac:	29 89       	ldd	r18, Y+17	; 0x11
     4ae:	3a 89       	ldd	r19, Y+18	; 0x12
    uint16_t millia = a.millis;
     4b0:	4b 89       	ldd	r20, Y+19	; 0x13
     4b2:	5c 89       	ldd	r21, Y+20	; 0x14
    uint16_t seconda = a.seconds;
     4b4:	6d 89       	ldd	r22, Y+21	; 0x15
     4b6:	7e 89       	ldd	r23, Y+22	; 0x16
    uint16_t hoursa = a.hours;
     4b8:	8f 89       	ldd	r24, Y+23	; 0x17
     4ba:	98 8d       	ldd	r25, Y+24	; 0x18
    
    uint16_t clockb = b.clock;
     4bc:	e9 8c       	ldd	r14, Y+25	; 0x19
     4be:	fa 8c       	ldd	r15, Y+26	; 0x1a
    uint16_t millib = b.millis;
     4c0:	0b 8d       	ldd	r16, Y+27	; 0x1b
     4c2:	1c 8d       	ldd	r17, Y+28	; 0x1c
    uint16_t secondb = b.seconds;
     4c4:	ad 8d       	ldd	r26, Y+29	; 0x1d
     4c6:	be 8d       	ldd	r27, Y+30	; 0x1e
    uint16_t hoursb = b.hours;
     4c8:	af 8c       	ldd	r10, Y+31	; 0x1f
     4ca:	b8 a0       	ldd	r11, Y+32	; 0x20
    
    while (clocka < clockb && millia > 0) {
     4cc:	2e 15       	cp	r18, r14
     4ce:	3f 05       	cpc	r19, r15
     4d0:	30 f5       	brcc	.+76     	; 0x51e <time_diff_internal+0x108>
     4d2:	41 15       	cp	r20, r1
     4d4:	51 05       	cpc	r21, r1
     4d6:	19 f1       	breq	.+70     	; 0x51e <time_diff_internal+0x108>
        millia--;
     4d8:	fa 01       	movw	r30, r20
     4da:	31 97       	sbiw	r30, 0x01	; 1
        clocka += 256;
     4dc:	33 95       	inc	r19
        if (millia == 0) {
     4de:	30 97       	sbiw	r30, 0x00	; 0
     4e0:	79 f4       	brne	.+30     	; 0x500 <time_diff_internal+0xea>
            seconda--;
     4e2:	6b 01       	movw	r12, r22
     4e4:	e1 e0       	ldi	r30, 0x01	; 1
     4e6:	ce 1a       	sub	r12, r30
     4e8:	d1 08       	sbc	r13, r1
            millia += 1000;
     4ea:	fa 01       	movw	r30, r20
     4ec:	e9 51       	subi	r30, 0x19	; 25
     4ee:	fc 4f       	sbci	r31, 0xFC	; 252
            if (seconda == 0) {
     4f0:	c1 14       	cp	r12, r1
     4f2:	d1 04       	cpc	r13, r1
     4f4:	21 f4       	brne	.+8      	; 0x4fe <time_diff_internal+0xe8>
                hoursa--;
     4f6:	01 97       	sbiw	r24, 0x01	; 1
                seconda += 3600;
     4f8:	61 5f       	subi	r22, 0xF1	; 241
     4fa:	71 4f       	sbci	r23, 0xF1	; 241
     4fc:	01 c0       	rjmp	.+2      	; 0x500 <time_diff_internal+0xea>
     4fe:	b6 01       	movw	r22, r12
     500:	af 01       	movw	r20, r30
     502:	e4 cf       	rjmp	.-56     	; 0x4cc <time_diff_internal+0xb6>
            }
        }
    }
    
    while (millia < millib && seconda > 0) {
     504:	61 15       	cp	r22, r1
     506:	71 05       	cpc	r23, r1
     508:	99 f0       	breq	.+38     	; 0x530 <time_diff_internal+0x11a>
        seconda--;
     50a:	fb 01       	movw	r30, r22
     50c:	31 97       	sbiw	r30, 0x01	; 1
        millia += 1000;
     50e:	48 51       	subi	r20, 0x18	; 24
     510:	5c 4f       	sbci	r21, 0xFC	; 252
        if (seconda == 0) {
     512:	30 97       	sbiw	r30, 0x00	; 0
     514:	19 f4       	brne	.+6      	; 0x51c <time_diff_internal+0x106>
            hoursa--;
     516:	01 97       	sbiw	r24, 0x01	; 1
            seconda += 3600;
     518:	e0 5f       	subi	r30, 0xF0	; 240
     51a:	f1 4f       	sbci	r31, 0xF1	; 241
     51c:	bf 01       	movw	r22, r30
                seconda += 3600;
            }
        }
    }
    
    while (millia < millib && seconda > 0) {
     51e:	40 17       	cp	r20, r16
     520:	51 07       	cpc	r21, r17
     522:	80 f3       	brcs	.-32     	; 0x504 <time_diff_internal+0xee>
     524:	05 c0       	rjmp	.+10     	; 0x530 <time_diff_internal+0x11a>
            hoursa--;
            seconda += 3600;
        }
    }
    
    while (seconda < secondb && hoursa > 0) {
     526:	00 97       	sbiw	r24, 0x00	; 0
     528:	31 f0       	breq	.+12     	; 0x536 <time_diff_internal+0x120>
        hoursa--;
     52a:	01 97       	sbiw	r24, 0x01	; 1
        seconda += 3600;
     52c:	60 5f       	subi	r22, 0xF0	; 240
     52e:	71 4f       	sbci	r23, 0xF1	; 241
            hoursa--;
            seconda += 3600;
        }
    }
    
    while (seconda < secondb && hoursa > 0) {
     530:	6a 17       	cp	r22, r26
     532:	7b 07       	cpc	r23, r27
     534:	c0 f3       	brcs	.-16     	; 0x526 <time_diff_internal+0x110>
        hoursa--;
        seconda += 3600;
    }
    
    time t;
    t.clock = clocka - clockb;
     536:	f9 01       	movw	r30, r18
     538:	ee 19       	sub	r30, r14
     53a:	ff 09       	sbc	r31, r15
     53c:	2e 2f       	mov	r18, r30
     53e:	fa 87       	std	Y+10, r31	; 0x0a
     540:	e9 87       	std	Y+9, r30	; 0x09
    t.millis = millia - millib;
     542:	fa 01       	movw	r30, r20
     544:	e0 1b       	sub	r30, r16
     546:	f1 0b       	sbc	r31, r17
     548:	4e 2f       	mov	r20, r30
     54a:	fc 87       	std	Y+12, r31	; 0x0c
     54c:	eb 87       	std	Y+11, r30	; 0x0b
    t.seconds = seconda - secondb;
     54e:	fb 01       	movw	r30, r22
     550:	ea 1b       	sub	r30, r26
     552:	fb 0b       	sbc	r31, r27
     554:	6e 2f       	mov	r22, r30
     556:	fe 87       	std	Y+14, r31	; 0x0e
     558:	ed 87       	std	Y+13, r30	; 0x0d
    t.hours = hoursa - hoursb;
     55a:	8a 19       	sub	r24, r10
     55c:	9b 09       	sbc	r25, r11
     55e:	98 8b       	std	Y+16, r25	; 0x10
     560:	8f 87       	std	Y+15, r24	; 0x0f
    return time_update(t, 0);
     562:	00 e0       	ldi	r16, 0x00	; 0
     564:	10 e0       	ldi	r17, 0x00	; 0
     566:	3a 85       	ldd	r19, Y+10	; 0x0a
     568:	5c 85       	ldd	r21, Y+12	; 0x0c
     56a:	7e 85       	ldd	r23, Y+14	; 0x0e
     56c:	98 89       	ldd	r25, Y+16	; 0x10
     56e:	0e 94 28 01 	call	0x250	; 0x250 <time_update>
     572:	29 83       	std	Y+1, r18	; 0x01
     574:	3a 83       	std	Y+2, r19	; 0x02
     576:	4b 83       	std	Y+3, r20	; 0x03
     578:	5c 83       	std	Y+4, r21	; 0x04
     57a:	6d 83       	std	Y+5, r22	; 0x05
     57c:	7e 83       	std	Y+6, r23	; 0x06
     57e:	8f 83       	std	Y+7, r24	; 0x07
     580:	98 87       	std	Y+8, r25	; 0x08
     582:	29 81       	ldd	r18, Y+1	; 0x01
     584:	3a 81       	ldd	r19, Y+2	; 0x02
     586:	4b 81       	ldd	r20, Y+3	; 0x03
     588:	5c 81       	ldd	r21, Y+4	; 0x04
     58a:	6d 81       	ldd	r22, Y+5	; 0x05
     58c:	7e 81       	ldd	r23, Y+6	; 0x06
}
     58e:	8f 81       	ldd	r24, Y+7	; 0x07
     590:	98 85       	ldd	r25, Y+8	; 0x08
     592:	a0 96       	adiw	r28, 0x20	; 32
     594:	0f b6       	in	r0, 0x3f	; 63
     596:	f8 94       	cli
     598:	de bf       	out	0x3e, r29	; 62
     59a:	0f be       	out	0x3f, r0	; 63
     59c:	cd bf       	out	0x3d, r28	; 61
     59e:	df 91       	pop	r29
     5a0:	cf 91       	pop	r28
     5a2:	1f 91       	pop	r17
     5a4:	0f 91       	pop	r16
     5a6:	ff 90       	pop	r15
     5a8:	ef 90       	pop	r14
     5aa:	df 90       	pop	r13
     5ac:	cf 90       	pop	r12
     5ae:	bf 90       	pop	r11
     5b0:	af 90       	pop	r10
     5b2:	9f 90       	pop	r9
     5b4:	8f 90       	pop	r8
     5b6:	7f 90       	pop	r7
     5b8:	6f 90       	pop	r6
     5ba:	08 95       	ret

000005bc <time_diff>:

time time_diff(time a, time b) {
     5bc:	6f 92       	push	r6
     5be:	7f 92       	push	r7
     5c0:	8f 92       	push	r8
     5c2:	9f 92       	push	r9
     5c4:	af 92       	push	r10
     5c6:	bf 92       	push	r11
     5c8:	cf 92       	push	r12
     5ca:	df 92       	push	r13
     5cc:	ef 92       	push	r14
     5ce:	ff 92       	push	r15
     5d0:	0f 93       	push	r16
     5d2:	1f 93       	push	r17
     5d4:	cf 93       	push	r28
     5d6:	df 93       	push	r29
     5d8:	cd b7       	in	r28, 0x3d	; 61
     5da:	de b7       	in	r29, 0x3e	; 62
     5dc:	68 97       	sbiw	r28, 0x18	; 24
     5de:	0f b6       	in	r0, 0x3f	; 63
     5e0:	f8 94       	cli
     5e2:	de bf       	out	0x3e, r29	; 62
     5e4:	0f be       	out	0x3f, r0	; 63
     5e6:	cd bf       	out	0x3d, r28	; 61
     5e8:	e2 2f       	mov	r30, r18
     5ea:	29 87       	std	Y+9, r18	; 0x09
     5ec:	f3 2f       	mov	r31, r19
     5ee:	3a 87       	std	Y+10, r19	; 0x0a
     5f0:	a4 2f       	mov	r26, r20
     5f2:	4b 87       	std	Y+11, r20	; 0x0b
     5f4:	b5 2f       	mov	r27, r21
     5f6:	5c 87       	std	Y+12, r21	; 0x0c
     5f8:	96 2e       	mov	r9, r22
     5fa:	6d 87       	std	Y+13, r22	; 0x0d
     5fc:	87 2e       	mov	r8, r23
     5fe:	7e 87       	std	Y+14, r23	; 0x0e
     600:	78 2e       	mov	r7, r24
     602:	8f 87       	std	Y+15, r24	; 0x0f
     604:	69 2e       	mov	r6, r25
     606:	98 8b       	std	Y+16, r25	; 0x10
     608:	2a 2d       	mov	r18, r10
     60a:	a9 8a       	std	Y+17, r10	; 0x11
     60c:	3b 2d       	mov	r19, r11
     60e:	ba 8a       	std	Y+18, r11	; 0x12
     610:	4c 2d       	mov	r20, r12
     612:	cb 8a       	std	Y+19, r12	; 0x13
     614:	5d 2d       	mov	r21, r13
     616:	dc 8a       	std	Y+20, r13	; 0x14
     618:	6e 2d       	mov	r22, r14
     61a:	ed 8a       	std	Y+21, r14	; 0x15
     61c:	7f 2d       	mov	r23, r15
     61e:	fe 8a       	std	Y+22, r15	; 0x16
     620:	80 2f       	mov	r24, r16
     622:	0f 8b       	std	Y+23, r16	; 0x17
     624:	91 2f       	mov	r25, r17
     626:	18 8f       	std	Y+24, r17	; 0x18
    if (time_is_greater(b, a)) {
     628:	5f 01       	movw	r10, r30
     62a:	6d 01       	movw	r12, r26
     62c:	e9 2c       	mov	r14, r9
     62e:	f8 2c       	mov	r15, r8
     630:	07 2d       	mov	r16, r7
     632:	16 2d       	mov	r17, r6
     634:	0e 94 cb 00 	call	0x196	; 0x196 <time_is_greater>
     638:	88 23       	and	r24, r24
     63a:	49 f0       	breq	.+18     	; 0x64e <time_diff+0x92>
        return time_diff_internal(b, a);
     63c:	29 89       	ldd	r18, Y+17	; 0x11
     63e:	3a 89       	ldd	r19, Y+18	; 0x12
     640:	4b 89       	ldd	r20, Y+19	; 0x13
     642:	5c 89       	ldd	r21, Y+20	; 0x14
     644:	6d 89       	ldd	r22, Y+21	; 0x15
     646:	7e 89       	ldd	r23, Y+22	; 0x16
     648:	8f 89       	ldd	r24, Y+23	; 0x17
     64a:	98 8d       	ldd	r25, Y+24	; 0x18
     64c:	10 c0       	rjmp	.+32     	; 0x66e <time_diff+0xb2>
    }
    
    return time_diff_internal(a, b);
     64e:	a9 88       	ldd	r10, Y+17	; 0x11
     650:	ba 88       	ldd	r11, Y+18	; 0x12
     652:	cb 88       	ldd	r12, Y+19	; 0x13
     654:	dc 88       	ldd	r13, Y+20	; 0x14
     656:	ed 88       	ldd	r14, Y+21	; 0x15
     658:	fe 88       	ldd	r15, Y+22	; 0x16
     65a:	0f 89       	ldd	r16, Y+23	; 0x17
     65c:	18 8d       	ldd	r17, Y+24	; 0x18
     65e:	29 85       	ldd	r18, Y+9	; 0x09
     660:	3a 85       	ldd	r19, Y+10	; 0x0a
     662:	4b 85       	ldd	r20, Y+11	; 0x0b
     664:	5c 85       	ldd	r21, Y+12	; 0x0c
     666:	6d 85       	ldd	r22, Y+13	; 0x0d
     668:	7e 85       	ldd	r23, Y+14	; 0x0e
     66a:	8f 85       	ldd	r24, Y+15	; 0x0f
     66c:	98 89       	ldd	r25, Y+16	; 0x10
     66e:	0e 94 0b 02 	call	0x416	; 0x416 <time_diff_internal>
     672:	29 83       	std	Y+1, r18	; 0x01
     674:	3a 83       	std	Y+2, r19	; 0x02
     676:	4b 83       	std	Y+3, r20	; 0x03
     678:	5c 83       	std	Y+4, r21	; 0x04
     67a:	6d 83       	std	Y+5, r22	; 0x05
     67c:	7e 83       	std	Y+6, r23	; 0x06
     67e:	8f 83       	std	Y+7, r24	; 0x07
     680:	98 87       	std	Y+8, r25	; 0x08
     682:	29 81       	ldd	r18, Y+1	; 0x01
     684:	3a 81       	ldd	r19, Y+2	; 0x02
     686:	4b 81       	ldd	r20, Y+3	; 0x03
     688:	5c 81       	ldd	r21, Y+4	; 0x04
     68a:	6d 81       	ldd	r22, Y+5	; 0x05
     68c:	7e 81       	ldd	r23, Y+6	; 0x06
}
     68e:	8f 81       	ldd	r24, Y+7	; 0x07
     690:	98 85       	ldd	r25, Y+8	; 0x08
     692:	68 96       	adiw	r28, 0x18	; 24
     694:	0f b6       	in	r0, 0x3f	; 63
     696:	f8 94       	cli
     698:	de bf       	out	0x3e, r29	; 62
     69a:	0f be       	out	0x3f, r0	; 63
     69c:	cd bf       	out	0x3d, r28	; 61
     69e:	df 91       	pop	r29
     6a0:	cf 91       	pop	r28
     6a2:	1f 91       	pop	r17
     6a4:	0f 91       	pop	r16
     6a6:	ff 90       	pop	r15
     6a8:	ef 90       	pop	r14
     6aa:	df 90       	pop	r13
     6ac:	cf 90       	pop	r12
     6ae:	bf 90       	pop	r11
     6b0:	af 90       	pop	r10
     6b2:	9f 90       	pop	r9
     6b4:	8f 90       	pop	r8
     6b6:	7f 90       	pop	r7
     6b8:	6f 90       	pop	r6
     6ba:	08 95       	ret

000006bc <time_str>:

void time_str(char* str, time t) {
     6bc:	0f 93       	push	r16
     6be:	1f 93       	push	r17
     6c0:	cf 93       	push	r28
     6c2:	df 93       	push	r29
     6c4:	cd b7       	in	r28, 0x3d	; 61
     6c6:	de b7       	in	r29, 0x3e	; 62
     6c8:	28 97       	sbiw	r28, 0x08	; 8
     6ca:	0f b6       	in	r0, 0x3f	; 63
     6cc:	f8 94       	cli
     6ce:	de bf       	out	0x3e, r29	; 62
     6d0:	0f be       	out	0x3f, r0	; 63
     6d2:	cd bf       	out	0x3d, r28	; 61
     6d4:	2b 83       	std	Y+3, r18	; 0x03
     6d6:	4d 83       	std	Y+5, r20	; 0x05
     6d8:	5e 83       	std	Y+6, r21	; 0x06
     6da:	6f 83       	std	Y+7, r22	; 0x07
     6dc:	78 87       	std	Y+8, r23	; 0x08
    sprintf(str, "%uh %us %ums", t.hours, t.seconds, t.millis);
     6de:	3f 93       	push	r19
     6e0:	2b 81       	ldd	r18, Y+3	; 0x03
     6e2:	2f 93       	push	r18
     6e4:	2e 81       	ldd	r18, Y+6	; 0x06
     6e6:	2f 93       	push	r18
     6e8:	2d 81       	ldd	r18, Y+5	; 0x05
     6ea:	2f 93       	push	r18
     6ec:	28 85       	ldd	r18, Y+8	; 0x08
     6ee:	2f 93       	push	r18
     6f0:	2f 81       	ldd	r18, Y+7	; 0x07
     6f2:	2f 93       	push	r18
     6f4:	25 e1       	ldi	r18, 0x15	; 21
     6f6:	31 e0       	ldi	r19, 0x01	; 1
     6f8:	3f 93       	push	r19
     6fa:	2f 93       	push	r18
     6fc:	9f 93       	push	r25
     6fe:	8f 93       	push	r24
     700:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <sprintf>
     704:	0f b6       	in	r0, 0x3f	; 63
     706:	f8 94       	cli
     708:	de bf       	out	0x3e, r29	; 62
     70a:	0f be       	out	0x3f, r0	; 63
     70c:	cd bf       	out	0x3d, r28	; 61
}
     70e:	28 96       	adiw	r28, 0x08	; 8
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	de bf       	out	0x3e, r29	; 62
     716:	0f be       	out	0x3f, r0	; 63
     718:	cd bf       	out	0x3d, r28	; 61
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	1f 91       	pop	r17
     720:	0f 91       	pop	r16
     722:	08 95       	ret

00000724 <__vector_23>:

volatile time timer;
ISR(TIMER0_OVF_vect) {
     724:	1f 92       	push	r1
     726:	0f 92       	push	r0
     728:	0f b6       	in	r0, 0x3f	; 63
     72a:	0f 92       	push	r0
     72c:	11 24       	eor	r1, r1
     72e:	0b b6       	in	r0, 0x3b	; 59
     730:	0f 92       	push	r0
     732:	0f 93       	push	r16
     734:	1f 93       	push	r17
     736:	2f 93       	push	r18
     738:	3f 93       	push	r19
     73a:	4f 93       	push	r20
     73c:	5f 93       	push	r21
     73e:	6f 93       	push	r22
     740:	7f 93       	push	r23
     742:	8f 93       	push	r24
     744:	9f 93       	push	r25
     746:	af 93       	push	r26
     748:	bf 93       	push	r27
     74a:	ef 93       	push	r30
     74c:	ff 93       	push	r31
    // Using 8bit timer we've traversed 256 clock cycles
    timer = time_update(timer, 256);
     74e:	00 e0       	ldi	r16, 0x00	; 0
     750:	11 e0       	ldi	r17, 0x01	; 1
     752:	20 91 89 01 	lds	r18, 0x0189
     756:	30 91 8a 01 	lds	r19, 0x018A
     75a:	40 91 8b 01 	lds	r20, 0x018B
     75e:	50 91 8c 01 	lds	r21, 0x018C
     762:	60 91 8d 01 	lds	r22, 0x018D
     766:	70 91 8e 01 	lds	r23, 0x018E
     76a:	80 91 8f 01 	lds	r24, 0x018F
     76e:	90 91 90 01 	lds	r25, 0x0190
     772:	0e 94 28 01 	call	0x250	; 0x250 <time_update>
     776:	e9 e8       	ldi	r30, 0x89	; 137
     778:	f1 e0       	ldi	r31, 0x01	; 1
     77a:	20 83       	st	Z, r18
     77c:	31 83       	std	Z+1, r19	; 0x01
     77e:	42 83       	std	Z+2, r20	; 0x02
     780:	53 83       	std	Z+3, r21	; 0x03
     782:	64 83       	std	Z+4, r22	; 0x04
     784:	75 83       	std	Z+5, r23	; 0x05
     786:	86 83       	std	Z+6, r24	; 0x06
     788:	97 83       	std	Z+7, r25	; 0x07
}
     78a:	ff 91       	pop	r31
     78c:	ef 91       	pop	r30
     78e:	bf 91       	pop	r27
     790:	af 91       	pop	r26
     792:	9f 91       	pop	r25
     794:	8f 91       	pop	r24
     796:	7f 91       	pop	r23
     798:	6f 91       	pop	r22
     79a:	5f 91       	pop	r21
     79c:	4f 91       	pop	r20
     79e:	3f 91       	pop	r19
     7a0:	2f 91       	pop	r18
     7a2:	1f 91       	pop	r17
     7a4:	0f 91       	pop	r16
     7a6:	0f 90       	pop	r0
     7a8:	0b be       	out	0x3b, r0	; 59
     7aa:	0f 90       	pop	r0
     7ac:	0f be       	out	0x3f, r0	; 63
     7ae:	0f 90       	pop	r0
     7b0:	1f 90       	pop	r1
     7b2:	18 95       	reti

000007b4 <timer_start>:

void timer_start(void) {
    // Setup our timer interrupt
    TCCR0A = 0;
     7b4:	14 bc       	out	0x24, r1	; 36
    TCCR0B = 0;
     7b6:	15 bc       	out	0x25, r1	; 37
    TCNT0 = 0;
     7b8:	16 bc       	out	0x26, r1	; 38
    TIMSK0 = _BV(TOIE0);
     7ba:	81 e0       	ldi	r24, 0x01	; 1
     7bc:	80 93 6e 00 	sts	0x006E, r24
    timer.clock = 0;
     7c0:	10 92 8a 01 	sts	0x018A, r1
     7c4:	10 92 89 01 	sts	0x0189, r1
    timer.millis = 0;
     7c8:	10 92 8c 01 	sts	0x018C, r1
     7cc:	10 92 8b 01 	sts	0x018B, r1
    timer.seconds = 0;
     7d0:	10 92 8e 01 	sts	0x018E, r1
     7d4:	10 92 8d 01 	sts	0x018D, r1
    timer.hours = 0;
     7d8:	10 92 90 01 	sts	0x0190, r1
     7dc:	10 92 8f 01 	sts	0x018F, r1
    // Start it!
    TCCR0B = 1;
     7e0:	85 bd       	out	0x25, r24	; 37
     7e2:	08 95       	ret

000007e4 <timer_stop>:
}

void timer_stop(void) {
    TCCR0A = 0;
     7e4:	14 bc       	out	0x24, r1	; 36
    TCCR0B = 0;
     7e6:	15 bc       	out	0x25, r1	; 37
    TCNT0 = 0;
     7e8:	16 bc       	out	0x26, r1	; 38
    TIMSK0 = _BV(TOIE0);
     7ea:	81 e0       	ldi	r24, 0x01	; 1
     7ec:	80 93 6e 00 	sts	0x006E, r24
    timer.clock = 0;
     7f0:	10 92 8a 01 	sts	0x018A, r1
     7f4:	10 92 89 01 	sts	0x0189, r1
    timer.millis = 0;
     7f8:	10 92 8c 01 	sts	0x018C, r1
     7fc:	10 92 8b 01 	sts	0x018B, r1
    timer.seconds = 0;
     800:	10 92 8e 01 	sts	0x018E, r1
     804:	10 92 8d 01 	sts	0x018D, r1
    timer.hours = 0;
     808:	10 92 90 01 	sts	0x0190, r1
     80c:	10 92 8f 01 	sts	0x018F, r1
     810:	08 95       	ret

00000812 <time_set_global>:
}

void time_set_global(time* t) {
     812:	fc 01       	movw	r30, r24
    t->clock = timer.clock;
     814:	80 91 89 01 	lds	r24, 0x0189
     818:	90 91 8a 01 	lds	r25, 0x018A
     81c:	91 83       	std	Z+1, r25	; 0x01
     81e:	80 83       	st	Z, r24
    t->millis = timer.millis;
     820:	80 91 8b 01 	lds	r24, 0x018B
     824:	90 91 8c 01 	lds	r25, 0x018C
     828:	93 83       	std	Z+3, r25	; 0x03
     82a:	82 83       	std	Z+2, r24	; 0x02
    t->seconds = timer.seconds;
     82c:	80 91 8d 01 	lds	r24, 0x018D
     830:	90 91 8e 01 	lds	r25, 0x018E
     834:	95 83       	std	Z+5, r25	; 0x05
     836:	84 83       	std	Z+4, r24	; 0x04
    t->hours = timer.hours;
     838:	80 91 8f 01 	lds	r24, 0x018F
     83c:	90 91 90 01 	lds	r25, 0x0190
     840:	97 83       	std	Z+7, r25	; 0x07
     842:	86 83       	std	Z+6, r24	; 0x06
     844:	08 95       	ret

00000846 <lcd_clear>:
}

void lcd_clear(hd44780* lcd, char* str) {
     846:	0f 93       	push	r16
     848:	1f 93       	push	r17
     84a:	cf 93       	push	r28
     84c:	df 93       	push	r29
     84e:	ec 01       	movw	r28, r24
     850:	8b 01       	movw	r16, r22
    uint8_t flags = lcd_display_clear_flags();
     852:	0e 94 24 09 	call	0x1248	; 0x1248 <lcd_display_clear_flags>
    lcd_send_command(lcd, flags);
     856:	68 2f       	mov	r22, r24
     858:	ce 01       	movw	r24, r28
     85a:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <lcd_send_command>
    flags = lcd_return_home_flags();
     85e:	0e 94 41 09 	call	0x1282	; 0x1282 <lcd_return_home_flags>
    lcd_send_command(lcd, flags);
     862:	68 2f       	mov	r22, r24
     864:	ce 01       	movw	r24, r28
     866:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <lcd_send_command>
    if (strcmp(str, "") != 0) {
     86a:	f8 01       	movw	r30, r16
     86c:	80 81       	ld	r24, Z
     86e:	88 23       	and	r24, r24
     870:	41 f0       	breq	.+16     	; 0x882 <lcd_clear+0x3c>
        lcd_write(lcd, str);
     872:	b8 01       	movw	r22, r16
     874:	ce 01       	movw	r24, r28
    }
}
     876:	df 91       	pop	r29
     878:	cf 91       	pop	r28
     87a:	1f 91       	pop	r17
     87c:	0f 91       	pop	r16
    uint8_t flags = lcd_display_clear_flags();
    lcd_send_command(lcd, flags);
    flags = lcd_return_home_flags();
    lcd_send_command(lcd, flags);
    if (strcmp(str, "") != 0) {
        lcd_write(lcd, str);
     87e:	0c 94 0a 0b 	jmp	0x1614	; 0x1614 <lcd_write>
    }
}
     882:	df 91       	pop	r29
     884:	cf 91       	pop	r28
     886:	1f 91       	pop	r17
     888:	0f 91       	pop	r16
     88a:	08 95       	ret

0000088c <foodunit_update_current_screen>:
void foodunit_drain(foodunit* f);
void foodunit_update_h2o_check(foodunit* f);
void foodunit_fill(foodunit* f);
void foodunit_update(foodunit* f);

void foodunit_update_current_screen(foodunit* f) {
     88c:	08 95       	ret

0000088e <foodunit_read_user>:
        default:
            break;
    }
}

int8_t foodunit_read_user(foodunit* f, uint8_t x, uint8_t y, const char* suffix) {
     88e:	5f 92       	push	r5
     890:	6f 92       	push	r6
     892:	7f 92       	push	r7
     894:	8f 92       	push	r8
     896:	9f 92       	push	r9
     898:	af 92       	push	r10
     89a:	bf 92       	push	r11
     89c:	cf 92       	push	r12
     89e:	df 92       	push	r13
     8a0:	ef 92       	push	r14
     8a2:	ff 92       	push	r15
     8a4:	0f 93       	push	r16
     8a6:	1f 93       	push	r17
     8a8:	cf 93       	push	r28
     8aa:	df 93       	push	r29
     8ac:	cd b7       	in	r28, 0x3d	; 61
     8ae:	de b7       	in	r29, 0x3e	; 62
     8b0:	64 97       	sbiw	r28, 0x14	; 20
     8b2:	0f b6       	in	r0, 0x3f	; 63
     8b4:	f8 94       	cli
     8b6:	de bf       	out	0x3e, r29	; 62
     8b8:	0f be       	out	0x3f, r0	; 63
     8ba:	cd bf       	out	0x3d, r28	; 61
     8bc:	76 2e       	mov	r7, r22
     8be:	64 2e       	mov	r6, r20
    f->enc.steps = 0;
     8c0:	8c 01       	movw	r16, r24
     8c2:	0d 58       	subi	r16, 0x8D	; 141
     8c4:	1f 4f       	sbci	r17, 0xFF	; 255
     8c6:	f8 01       	movw	r30, r16
     8c8:	10 82       	st	Z, r1
    char str[20];
    int8_t steps = f->enc.steps;
     8ca:	51 2c       	mov	r5, r1
    while (!encoder_btn_up_edge(&f->enc)) {
     8cc:	6c 01       	movw	r12, r24
     8ce:	fc e5       	ldi	r31, 0x5C	; 92
     8d0:	cf 0e       	add	r12, r31
     8d2:	d1 1c       	adc	r13, r1
        encoder_update(&f->enc);
        if (steps != f->enc.steps) {
            lcd_xy(&f->lcd, x, y);
     8d4:	5c 01       	movw	r10, r24
     8d6:	2e e0       	ldi	r18, 0x0E	; 14
     8d8:	a2 0e       	add	r10, r18
     8da:	b1 1c       	adc	r11, r1
            sprintf(str, "%3i",f->enc.steps);
     8dc:	82 e2       	ldi	r24, 0x22	; 34
     8de:	88 2e       	mov	r8, r24
     8e0:	81 e0       	ldi	r24, 0x01	; 1
     8e2:	98 2e       	mov	r9, r24
     8e4:	ce 01       	movw	r24, r28
     8e6:	01 96       	adiw	r24, 0x01	; 1
     8e8:	7c 01       	movw	r14, r24

int8_t foodunit_read_user(foodunit* f, uint8_t x, uint8_t y, const char* suffix) {
    f->enc.steps = 0;
    char str[20];
    int8_t steps = f->enc.steps;
    while (!encoder_btn_up_edge(&f->enc)) {
     8ea:	c6 01       	movw	r24, r12
     8ec:	0e 94 c3 08 	call	0x1186	; 0x1186 <encoder_btn_up_edge>
     8f0:	81 11       	cpse	r24, r1
     8f2:	27 c0       	rjmp	.+78     	; 0x942 <foodunit_read_user+0xb4>
        encoder_update(&f->enc);
     8f4:	c6 01       	movw	r24, r12
     8f6:	0e 94 97 08 	call	0x112e	; 0x112e <encoder_update>
        if (steps != f->enc.steps) {
     8fa:	f8 01       	movw	r30, r16
     8fc:	80 81       	ld	r24, Z
     8fe:	58 16       	cp	r5, r24
     900:	a1 f3       	breq	.-24     	; 0x8ea <foodunit_read_user+0x5c>
            lcd_xy(&f->lcd, x, y);
     902:	46 2d       	mov	r20, r6
     904:	67 2d       	mov	r22, r7
     906:	c5 01       	movw	r24, r10
     908:	0e 94 2f 0b 	call	0x165e	; 0x165e <lcd_xy>
            sprintf(str, "%3i",f->enc.steps);
     90c:	f8 01       	movw	r30, r16
     90e:	20 81       	ld	r18, Z
     910:	82 2f       	mov	r24, r18
     912:	99 27       	eor	r25, r25
     914:	87 fd       	sbrc	r24, 7
     916:	90 95       	com	r25
     918:	9f 93       	push	r25
     91a:	2f 93       	push	r18
     91c:	9f 92       	push	r9
     91e:	8f 92       	push	r8
     920:	ff 92       	push	r15
     922:	ef 92       	push	r14
     924:	0e 94 b1 0e 	call	0x1d62	; 0x1d62 <sprintf>
            lcd_write(&f->lcd, str);
     928:	b7 01       	movw	r22, r14
     92a:	c5 01       	movw	r24, r10
     92c:	0e 94 0a 0b 	call	0x1614	; 0x1614 <lcd_write>
            steps = f->enc.steps;
     930:	f8 01       	movw	r30, r16
     932:	50 80       	ld	r5, Z
     934:	0f 90       	pop	r0
     936:	0f 90       	pop	r0
     938:	0f 90       	pop	r0
     93a:	0f 90       	pop	r0
     93c:	0f 90       	pop	r0
     93e:	0f 90       	pop	r0
     940:	d4 cf       	rjmp	.-88     	; 0x8ea <foodunit_read_user+0x5c>
        }
    }
    return 0;
}
     942:	80 e0       	ldi	r24, 0x00	; 0
     944:	64 96       	adiw	r28, 0x14	; 20
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	f8 94       	cli
     94a:	de bf       	out	0x3e, r29	; 62
     94c:	0f be       	out	0x3f, r0	; 63
     94e:	cd bf       	out	0x3d, r28	; 61
     950:	df 91       	pop	r29
     952:	cf 91       	pop	r28
     954:	1f 91       	pop	r17
     956:	0f 91       	pop	r16
     958:	ff 90       	pop	r15
     95a:	ef 90       	pop	r14
     95c:	df 90       	pop	r13
     95e:	cf 90       	pop	r12
     960:	bf 90       	pop	r11
     962:	af 90       	pop	r10
     964:	9f 90       	pop	r9
     966:	8f 90       	pop	r8
     968:	7f 90       	pop	r7
     96a:	6f 90       	pop	r6
     96c:	5f 90       	pop	r5
     96e:	08 95       	ret

00000970 <foodunit_display>:

void foodunit_display(foodunit* f, screen s) {
     970:	df 92       	push	r13
     972:	ef 92       	push	r14
     974:	ff 92       	push	r15
     976:	0f 93       	push	r16
     978:	1f 93       	push	r17
     97a:	cf 93       	push	r28
     97c:	df 93       	push	r29
     97e:	ec 01       	movw	r28, r24
     980:	d6 2e       	mov	r13, r22
    // We've already displayed the current screen, all we may need to do is
    // update it.
    if (f->screen == s) {
     982:	7c 01       	movw	r14, r24
     984:	84 e7       	ldi	r24, 0x74	; 116
     986:	e8 0e       	add	r14, r24
     988:	f1 1c       	adc	r15, r1
     98a:	f7 01       	movw	r30, r14
     98c:	80 81       	ld	r24, Z
     98e:	86 17       	cp	r24, r22
     990:	e1 f1       	breq	.+120    	; 0xa0a <foodunit_display+0x9a>
     992:	8e 01       	movw	r16, r28
     994:	02 5f       	subi	r16, 0xF2	; 242
     996:	1f 4f       	sbci	r17, 0xFF	; 255
        foodunit_update_current_screen(f);
        return;
    }
    
    // This is where we do the initial screen setup.
    switch (s) {
     998:	f1 e0       	ldi	r31, 0x01	; 1
     99a:	6f 17       	cp	r22, r31
     99c:	89 f0       	breq	.+34     	; 0x9c0 <foodunit_display+0x50>
     99e:	82 e0       	ldi	r24, 0x02	; 2
     9a0:	68 13       	cpse	r22, r24
     9a2:	2c c0       	rjmp	.+88     	; 0x9fc <foodunit_display+0x8c>
            foodunit_display(f, screen_menu);
            break;
        }
            
        case screen_menu: {
            lcd_clear(&f->lcd, "Please set the drain\nduration.");
     9a4:	6a e5       	ldi	r22, 0x5A	; 90
     9a6:	71 e0       	ldi	r23, 0x01	; 1
     9a8:	c8 01       	movw	r24, r16
     9aa:	0e 94 23 04 	call	0x846	; 0x846 <lcd_clear>
            foodunit_read_user(f, 0, 3, "minutes");
     9ae:	29 e7       	ldi	r18, 0x79	; 121
     9b0:	31 e0       	ldi	r19, 0x01	; 1
     9b2:	43 e0       	ldi	r20, 0x03	; 3
     9b4:	60 e0       	ldi	r22, 0x00	; 0
     9b6:	ce 01       	movw	r24, r28
     9b8:	0e 94 47 04 	call	0x88e	; 0x88e <foodunit_read_user>
            foodunit_display(f, screen_unknown);
     9bc:	60 e0       	ldi	r22, 0x00	; 0
     9be:	1a c0       	rjmp	.+52     	; 0x9f4 <foodunit_display+0x84>
    }
    
    // This is where we do the initial screen setup.
    switch (s) {
        case screen_startup: {
            lcd_clear(&f->lcd, "FoodUnit v0.0\nPlease push the\nencoder to start.\n>Ok");
     9c0:	66 e2       	ldi	r22, 0x26	; 38
     9c2:	71 e0       	ldi	r23, 0x01	; 1
     9c4:	c8 01       	movw	r24, r16
     9c6:	0e 94 23 04 	call	0x846	; 0x846 <lcd_clear>
            lcd_xy(&f->lcd, 0, 3);
     9ca:	43 e0       	ldi	r20, 0x03	; 3
     9cc:	60 e0       	ldi	r22, 0x00	; 0
     9ce:	c8 01       	movw	r24, r16
     9d0:	0e 94 2f 0b 	call	0x165e	; 0x165e <lcd_xy>
            while (!encoder_btn_up_edge(&f->enc)) {
     9d4:	8e 01       	movw	r16, r28
     9d6:	04 5a       	subi	r16, 0xA4	; 164
     9d8:	1f 4f       	sbci	r17, 0xFF	; 255
     9da:	c8 01       	movw	r24, r16
     9dc:	0e 94 c3 08 	call	0x1186	; 0x1186 <encoder_btn_up_edge>
     9e0:	81 11       	cpse	r24, r1
     9e2:	04 c0       	rjmp	.+8      	; 0x9ec <foodunit_display+0x7c>
                encoder_update(&f->enc);
     9e4:	c8 01       	movw	r24, r16
     9e6:	0e 94 97 08 	call	0x112e	; 0x112e <encoder_update>
     9ea:	f7 cf       	rjmp	.-18     	; 0x9da <foodunit_display+0x6a>
            }
            encoder_clear(&f->enc);
     9ec:	c8 01       	movw	r24, r16
     9ee:	0e 94 69 08 	call	0x10d2	; 0x10d2 <encoder_clear>
            foodunit_display(f, screen_menu);
     9f2:	62 e0       	ldi	r22, 0x02	; 2
        }
            
        case screen_menu: {
            lcd_clear(&f->lcd, "Please set the drain\nduration.");
            foodunit_read_user(f, 0, 3, "minutes");
            foodunit_display(f, screen_unknown);
     9f4:	ce 01       	movw	r24, r28
     9f6:	0e 94 b8 04 	call	0x970	; 0x970 <foodunit_display>
            break;
     9fa:	05 c0       	rjmp	.+10     	; 0xa06 <foodunit_display+0x96>
        }
            
        default:
            lcd_clear(&f->lcd, "wtf");
     9fc:	61 e8       	ldi	r22, 0x81	; 129
     9fe:	71 e0       	ldi	r23, 0x01	; 1
     a00:	c8 01       	movw	r24, r16
     a02:	0e 94 23 04 	call	0x846	; 0x846 <lcd_clear>
            break;
    }
    
    f->screen = s;
     a06:	f7 01       	movw	r30, r14
     a08:	d0 82       	st	Z, r13
}
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	1f 91       	pop	r17
     a10:	0f 91       	pop	r16
     a12:	ff 90       	pop	r15
     a14:	ef 90       	pop	r14
     a16:	df 90       	pop	r13
     a18:	08 95       	ret

00000a1a <foodunit_init>:

void foodunit_init(foodunit* f) {
     a1a:	bf 92       	push	r11
     a1c:	cf 92       	push	r12
     a1e:	df 92       	push	r13
     a20:	ef 92       	push	r14
     a22:	ff 92       	push	r15
     a24:	0f 93       	push	r16
     a26:	1f 93       	push	r17
     a28:	cf 93       	push	r28
     a2a:	df 93       	push	r29
     a2c:	ec 01       	movw	r28, r24
    // Analog h2o pin F0
    analogReference(ADC_REF_POWER);
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	0e 94 02 08 	call	0x1004	; 0x1004 <analogReference>
    f->h2o_sensor = pin_make(&PORTF, &DDRF, &PINF, 0);
     a34:	20 e0       	ldi	r18, 0x00	; 0
     a36:	4f e2       	ldi	r20, 0x2F	; 47
     a38:	50 e0       	ldi	r21, 0x00	; 0
     a3a:	60 e3       	ldi	r22, 0x30	; 48
     a3c:	70 e0       	ldi	r23, 0x00	; 0
     a3e:	81 e3       	ldi	r24, 0x31	; 49
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	0e 94 39 0b 	call	0x1672	; 0x1672 <pin_make>
     a46:	28 83       	st	Y, r18
     a48:	39 83       	std	Y+1, r19	; 0x01
     a4a:	4a 83       	std	Y+2, r20	; 0x02
     a4c:	5b 83       	std	Y+3, r21	; 0x03
     a4e:	6c 83       	std	Y+4, r22	; 0x04
     a50:	7d 83       	std	Y+5, r23	; 0x05
     a52:	8e 83       	std	Y+6, r24	; 0x06
    input_pin(f->h2o_sensor);
     a54:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <input_pin>
    
    // The pump relay.
    f->pump_relay = pin_make(&PORTB, &DDRB, &PINB, 6);
     a58:	26 e0       	ldi	r18, 0x06	; 6
     a5a:	43 e2       	ldi	r20, 0x23	; 35
     a5c:	50 e0       	ldi	r21, 0x00	; 0
     a5e:	64 e2       	ldi	r22, 0x24	; 36
     a60:	70 e0       	ldi	r23, 0x00	; 0
     a62:	85 e2       	ldi	r24, 0x25	; 37
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	0e 94 39 0b 	call	0x1672	; 0x1672 <pin_make>
     a6a:	2f 83       	std	Y+7, r18	; 0x07
     a6c:	38 87       	std	Y+8, r19	; 0x08
     a6e:	49 87       	std	Y+9, r20	; 0x09
     a70:	5a 87       	std	Y+10, r21	; 0x0a
     a72:	6b 87       	std	Y+11, r22	; 0x0b
     a74:	7c 87       	std	Y+12, r23	; 0x0c
     a76:	8d 87       	std	Y+13, r24	; 0x0d
    output_pin(f->pump_relay);
     a78:	0e 94 cf 0b 	call	0x179e	; 0x179e <output_pin>
    clear_pin(f->pump_relay);
     a7c:	2f 81       	ldd	r18, Y+7	; 0x07
     a7e:	38 85       	ldd	r19, Y+8	; 0x08
     a80:	49 85       	ldd	r20, Y+9	; 0x09
     a82:	5a 85       	ldd	r21, Y+10	; 0x0a
     a84:	6b 85       	ldd	r22, Y+11	; 0x0b
     a86:	7c 85       	ldd	r23, Y+12	; 0x0c
     a88:	8d 85       	ldd	r24, Y+13	; 0x0d
     a8a:	0e 94 82 0b 	call	0x1704	; 0x1704 <clear_pin>
    
    // Initial programmable values.
    f->draining = true;
     a8e:	fe 01       	movw	r30, r28
     a90:	eb 57       	subi	r30, 0x7B	; 123
     a92:	ff 4f       	sbci	r31, 0xFF	; 255
     a94:	81 e0       	ldi	r24, 0x01	; 1
     a96:	80 83       	st	Z, r24
    f->when_drain_ends = time_make(0, 0, 0, 0);
     a98:	8e 01       	movw	r16, r28
     a9a:	0b 58       	subi	r16, 0x8B	; 139
     a9c:	1f 4f       	sbci	r17, 0xFF	; 255
     a9e:	20 e0       	ldi	r18, 0x00	; 0
     aa0:	30 e0       	ldi	r19, 0x00	; 0
     aa2:	40 e0       	ldi	r20, 0x00	; 0
     aa4:	50 e0       	ldi	r21, 0x00	; 0
     aa6:	60 e0       	ldi	r22, 0x00	; 0
     aa8:	70 e0       	ldi	r23, 0x00	; 0
     aaa:	80 e0       	ldi	r24, 0x00	; 0
     aac:	90 e0       	ldi	r25, 0x00	; 0
     aae:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <time_make>
     ab2:	f8 01       	movw	r30, r16
     ab4:	20 83       	st	Z, r18
     ab6:	31 83       	std	Z+1, r19	; 0x01
     ab8:	42 83       	std	Z+2, r20	; 0x02
     aba:	53 83       	std	Z+3, r21	; 0x03
     abc:	64 83       	std	Z+4, r22	; 0x04
     abe:	75 83       	std	Z+5, r23	; 0x05
     ac0:	86 83       	std	Z+6, r24	; 0x06
     ac2:	97 83       	std	Z+7, r25	; 0x07
    f->next_h2o_check = time_make(0, 0, 0, 0);
     ac4:	08 5f       	subi	r16, 0xF8	; 248
     ac6:	1f 4f       	sbci	r17, 0xFF	; 255
     ac8:	20 e0       	ldi	r18, 0x00	; 0
     aca:	30 e0       	ldi	r19, 0x00	; 0
     acc:	40 e0       	ldi	r20, 0x00	; 0
     ace:	50 e0       	ldi	r21, 0x00	; 0
     ad0:	60 e0       	ldi	r22, 0x00	; 0
     ad2:	70 e0       	ldi	r23, 0x00	; 0
     ad4:	80 e0       	ldi	r24, 0x00	; 0
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <time_make>
     adc:	f8 01       	movw	r30, r16
     ade:	20 83       	st	Z, r18
     ae0:	31 83       	std	Z+1, r19	; 0x01
     ae2:	42 83       	std	Z+2, r20	; 0x02
     ae4:	53 83       	std	Z+3, r21	; 0x03
     ae6:	64 83       	std	Z+4, r22	; 0x04
     ae8:	75 83       	std	Z+5, r23	; 0x05
     aea:	86 83       	std	Z+6, r24	; 0x06
     aec:	97 83       	std	Z+7, r25	; 0x07
    f->drain_seconds = 10;
     aee:	39 96       	adiw	r30, 0x09	; 9
     af0:	8a e0       	ldi	r24, 0x0A	; 10
     af2:	90 e0       	ldi	r25, 0x00	; 0
     af4:	91 83       	std	Z+1, r25	; 0x01
     af6:	80 83       	st	Z, r24
    f->h2o_threshold = 50;
     af8:	32 96       	adiw	r30, 0x02	; 2
     afa:	82 e3       	ldi	r24, 0x32	; 50
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	91 83       	std	Z+1, r25	; 0x01
     b00:	80 83       	st	Z, r24
    f->screen = screen_unknown;
     b02:	74 97       	sbiw	r30, 0x14	; 20
     b04:	10 82       	st	Z, r1
    
    // The lcd screen.
    f->lcd.rs = pin_make(&PORTD, &DDRD, &PIND, 5);
     b06:	25 e0       	ldi	r18, 0x05	; 5
     b08:	49 e2       	ldi	r20, 0x29	; 41
     b0a:	50 e0       	ldi	r21, 0x00	; 0
     b0c:	6a e2       	ldi	r22, 0x2A	; 42
     b0e:	70 e0       	ldi	r23, 0x00	; 0
     b10:	8b e2       	ldi	r24, 0x2B	; 43
     b12:	90 e0       	ldi	r25, 0x00	; 0
     b14:	0e 94 39 0b 	call	0x1672	; 0x1672 <pin_make>
     b18:	2e 87       	std	Y+14, r18	; 0x0e
     b1a:	3f 87       	std	Y+15, r19	; 0x0f
     b1c:	48 8b       	std	Y+16, r20	; 0x10
     b1e:	59 8b       	std	Y+17, r21	; 0x11
     b20:	6a 8b       	std	Y+18, r22	; 0x12
     b22:	7b 8b       	std	Y+19, r23	; 0x13
     b24:	8c 8b       	std	Y+20, r24	; 0x14
    f->lcd.rw = pin_make(&PORTD, &DDRD, &PIND, 6);
     b26:	26 e0       	ldi	r18, 0x06	; 6
     b28:	49 e2       	ldi	r20, 0x29	; 41
     b2a:	50 e0       	ldi	r21, 0x00	; 0
     b2c:	6a e2       	ldi	r22, 0x2A	; 42
     b2e:	70 e0       	ldi	r23, 0x00	; 0
     b30:	8b e2       	ldi	r24, 0x2B	; 43
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	0e 94 39 0b 	call	0x1672	; 0x1672 <pin_make>
     b38:	2d 8b       	std	Y+21, r18	; 0x15
     b3a:	3e 8b       	std	Y+22, r19	; 0x16
     b3c:	4f 8b       	std	Y+23, r20	; 0x17
     b3e:	58 8f       	std	Y+24, r21	; 0x18
     b40:	69 8f       	std	Y+25, r22	; 0x19
     b42:	7a 8f       	std	Y+26, r23	; 0x1a
     b44:	8b 8f       	std	Y+27, r24	; 0x1b
    f->lcd.e = pin_make(&PORTD, &DDRD, &PIND, 7);
     b46:	27 e0       	ldi	r18, 0x07	; 7
     b48:	49 e2       	ldi	r20, 0x29	; 41
     b4a:	50 e0       	ldi	r21, 0x00	; 0
     b4c:	6a e2       	ldi	r22, 0x2A	; 42
     b4e:	70 e0       	ldi	r23, 0x00	; 0
     b50:	8b e2       	ldi	r24, 0x2B	; 43
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	0e 94 39 0b 	call	0x1672	; 0x1672 <pin_make>
     b58:	2c 8f       	std	Y+28, r18	; 0x1c
     b5a:	3d 8f       	std	Y+29, r19	; 0x1d
     b5c:	4e 8f       	std	Y+30, r20	; 0x1e
     b5e:	5f 8f       	std	Y+31, r21	; 0x1f
     b60:	68 a3       	std	Y+32, r22	; 0x20
     b62:	79 a3       	std	Y+33, r23	; 0x21
     b64:	8a a3       	std	Y+34, r24	; 0x22
    for (int i = 0; i < 8; i++) {
     b66:	e1 2c       	mov	r14, r1
     b68:	f1 2c       	mov	r15, r1
        f->lcd.db[i] = pin_make(&PORTC, &DDRC, &PINC, i);
     b6a:	97 e0       	ldi	r25, 0x07	; 7
     b6c:	b9 2e       	mov	r11, r25
     b6e:	be 9c       	mul	r11, r14
     b70:	60 01       	movw	r12, r0
     b72:	bf 9c       	mul	r11, r15
     b74:	d0 0c       	add	r13, r0
     b76:	11 24       	eor	r1, r1
     b78:	cc 0e       	add	r12, r28
     b7a:	dd 1e       	adc	r13, r29
     b7c:	86 01       	movw	r16, r12
     b7e:	0d 5d       	subi	r16, 0xDD	; 221
     b80:	1f 4f       	sbci	r17, 0xFF	; 255
     b82:	2e 2d       	mov	r18, r14
     b84:	46 e2       	ldi	r20, 0x26	; 38
     b86:	50 e0       	ldi	r21, 0x00	; 0
     b88:	67 e2       	ldi	r22, 0x27	; 39
     b8a:	70 e0       	ldi	r23, 0x00	; 0
     b8c:	88 e2       	ldi	r24, 0x28	; 40
     b8e:	90 e0       	ldi	r25, 0x00	; 0
     b90:	0e 94 39 0b 	call	0x1672	; 0x1672 <pin_make>
     b94:	f6 01       	movw	r30, r12
     b96:	23 a3       	std	Z+35, r18	; 0x23
     b98:	f8 01       	movw	r30, r16
     b9a:	31 83       	std	Z+1, r19	; 0x01
     b9c:	42 83       	std	Z+2, r20	; 0x02
     b9e:	53 83       	std	Z+3, r21	; 0x03
     ba0:	64 83       	std	Z+4, r22	; 0x04
     ba2:	75 83       	std	Z+5, r23	; 0x05
     ba4:	86 83       	std	Z+6, r24	; 0x06
    
    // The lcd screen.
    f->lcd.rs = pin_make(&PORTD, &DDRD, &PIND, 5);
    f->lcd.rw = pin_make(&PORTD, &DDRD, &PIND, 6);
    f->lcd.e = pin_make(&PORTD, &DDRD, &PIND, 7);
    for (int i = 0; i < 8; i++) {
     ba6:	ff ef       	ldi	r31, 0xFF	; 255
     ba8:	ef 1a       	sub	r14, r31
     baa:	ff 0a       	sbc	r15, r31
     bac:	88 e0       	ldi	r24, 0x08	; 8
     bae:	e8 16       	cp	r14, r24
     bb0:	f1 04       	cpc	r15, r1
     bb2:	e9 f6       	brne	.-70     	; 0xb6e <foodunit_init+0x154>
        f->lcd.db[i] = pin_make(&PORTC, &DDRC, &PINC, i);
    }
    f->lcd.mode = LCD_8BITS;
     bb4:	fe 01       	movw	r30, r28
     bb6:	e5 5a       	subi	r30, 0xA5	; 165
     bb8:	ff 4f       	sbci	r31, 0xFF	; 255
     bba:	81 e0       	ldi	r24, 0x01	; 1
     bbc:	80 83       	st	Z, r24
    lcd_init(&f->lcd);
     bbe:	8e 01       	movw	r16, r28
     bc0:	02 5f       	subi	r16, 0xF2	; 242
     bc2:	1f 4f       	sbci	r17, 0xFF	; 255
     bc4:	c8 01       	movw	r24, r16
     bc6:	0e 94 5f 0a 	call	0x14be	; 0x14be <lcd_init>
    lcd_send_command(&f->lcd, lcd_display_toggle_flags(LCD_DISPLAYON, LCD_CURSORON, LCD_CURSORBLINKOFF));
     bca:	40 e0       	ldi	r20, 0x00	; 0
     bcc:	61 e0       	ldi	r22, 0x01	; 1
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	0e 94 00 09 	call	0x1200	; 0x1200 <lcd_display_toggle_flags>
     bd4:	68 2f       	mov	r22, r24
     bd6:	c8 01       	movw	r24, r16
     bd8:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <lcd_send_command>
    
    // The rotary encoder/pushbutton
    encoder_init(&f->enc);
     bdc:	02 5b       	subi	r16, 0xB2	; 178
     bde:	1f 4f       	sbci	r17, 0xFF	; 255
     be0:	c8 01       	movw	r24, r16
     be2:	0e 94 29 08 	call	0x1052	; 0x1052 <encoder_init>
    f->enc.btn = pin_make(&PORTD, &DDRD, &PIND, 1);
     be6:	7e 01       	movw	r14, r28
     be8:	ea e6       	ldi	r30, 0x6A	; 106
     bea:	ee 0e       	add	r14, r30
     bec:	f1 1c       	adc	r15, r1
     bee:	21 e0       	ldi	r18, 0x01	; 1
     bf0:	49 e2       	ldi	r20, 0x29	; 41
     bf2:	50 e0       	ldi	r21, 0x00	; 0
     bf4:	6a e2       	ldi	r22, 0x2A	; 42
     bf6:	70 e0       	ldi	r23, 0x00	; 0
     bf8:	8b e2       	ldi	r24, 0x2B	; 43
     bfa:	90 e0       	ldi	r25, 0x00	; 0
     bfc:	0e 94 39 0b 	call	0x1672	; 0x1672 <pin_make>
     c00:	f7 01       	movw	r30, r14
     c02:	20 83       	st	Z, r18
     c04:	31 83       	std	Z+1, r19	; 0x01
     c06:	42 83       	std	Z+2, r20	; 0x02
     c08:	53 83       	std	Z+3, r21	; 0x03
     c0a:	64 83       	std	Z+4, r22	; 0x04
     c0c:	75 83       	std	Z+5, r23	; 0x05
     c0e:	86 83       	std	Z+6, r24	; 0x06
    set_pin(f->enc.btn); // pull up
     c10:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <set_pin>
    f->enc.a = pin_make(&PORTD, &DDRD, &PIND, 2);
     c14:	22 e0       	ldi	r18, 0x02	; 2
     c16:	49 e2       	ldi	r20, 0x29	; 41
     c18:	50 e0       	ldi	r21, 0x00	; 0
     c1a:	6a e2       	ldi	r22, 0x2A	; 42
     c1c:	70 e0       	ldi	r23, 0x00	; 0
     c1e:	8b e2       	ldi	r24, 0x2B	; 43
     c20:	90 e0       	ldi	r25, 0x00	; 0
     c22:	0e 94 39 0b 	call	0x1672	; 0x1672 <pin_make>
     c26:	f8 01       	movw	r30, r16
     c28:	20 83       	st	Z, r18
     c2a:	31 83       	std	Z+1, r19	; 0x01
     c2c:	42 83       	std	Z+2, r20	; 0x02
     c2e:	53 83       	std	Z+3, r21	; 0x03
     c30:	64 83       	std	Z+4, r22	; 0x04
     c32:	75 83       	std	Z+5, r23	; 0x05
     c34:	86 83       	std	Z+6, r24	; 0x06
    f->enc.b = pin_make(&PORTD, &DDRD, &PIND, 3);
     c36:	09 5f       	subi	r16, 0xF9	; 249
     c38:	1f 4f       	sbci	r17, 0xFF	; 255
     c3a:	23 e0       	ldi	r18, 0x03	; 3
     c3c:	49 e2       	ldi	r20, 0x29	; 41
     c3e:	50 e0       	ldi	r21, 0x00	; 0
     c40:	6a e2       	ldi	r22, 0x2A	; 42
     c42:	70 e0       	ldi	r23, 0x00	; 0
     c44:	8b e2       	ldi	r24, 0x2B	; 43
     c46:	90 e0       	ldi	r25, 0x00	; 0
     c48:	0e 94 39 0b 	call	0x1672	; 0x1672 <pin_make>
     c4c:	f8 01       	movw	r30, r16
     c4e:	20 83       	st	Z, r18
     c50:	31 83       	std	Z+1, r19	; 0x01
     c52:	42 83       	std	Z+2, r20	; 0x02
     c54:	53 83       	std	Z+3, r21	; 0x03
     c56:	64 83       	std	Z+4, r22	; 0x04
     c58:	75 83       	std	Z+5, r23	; 0x05
     c5a:	86 83       	std	Z+6, r24	; 0x06
    
    // Show our startup screen.
    foodunit_display(f, screen_startup);
     c5c:	61 e0       	ldi	r22, 0x01	; 1
     c5e:	ce 01       	movw	r24, r28
}
     c60:	df 91       	pop	r29
     c62:	cf 91       	pop	r28
     c64:	1f 91       	pop	r17
     c66:	0f 91       	pop	r16
     c68:	ff 90       	pop	r15
     c6a:	ef 90       	pop	r14
     c6c:	df 90       	pop	r13
     c6e:	cf 90       	pop	r12
     c70:	bf 90       	pop	r11
    set_pin(f->enc.btn); // pull up
    f->enc.a = pin_make(&PORTD, &DDRD, &PIND, 2);
    f->enc.b = pin_make(&PORTD, &DDRD, &PIND, 3);
    
    // Show our startup screen.
    foodunit_display(f, screen_startup);
     c72:	0c 94 b8 04 	jmp	0x970	; 0x970 <foodunit_display>

00000c76 <water_level>:
}

/** Read the water sensor. */
uint16_t water_level(pin* h2o) {
     c76:	ef 92       	push	r14
     c78:	ff 92       	push	r15
     c7a:	0f 93       	push	r16
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	7c 01       	movw	r14, r24
     c84:	0a e0       	ldi	r16, 0x0A	; 10
     c86:	10 e0       	ldi	r17, 0x00	; 0
    int avg = 0;
     c88:	c0 e0       	ldi	r28, 0x00	; 0
     c8a:	d0 e0       	ldi	r29, 0x00	; 0
    for (int i = 0; i < 10; i++) {
        uint16_t adc = adc_read(h2o->bit);
     c8c:	f7 01       	movw	r30, r14
     c8e:	86 81       	ldd	r24, Z+6	; 0x06
     c90:	0e 94 06 08 	call	0x100c	; 0x100c <adc_read>
        avg += adc;
     c94:	c8 0f       	add	r28, r24
     c96:	d9 1f       	adc	r29, r25
     c98:	01 50       	subi	r16, 0x01	; 1
     c9a:	11 09       	sbc	r17, r1
}

/** Read the water sensor. */
uint16_t water_level(pin* h2o) {
    int avg = 0;
    for (int i = 0; i < 10; i++) {
     c9c:	01 15       	cp	r16, r1
     c9e:	11 05       	cpc	r17, r1
     ca0:	a9 f7       	brne	.-22     	; 0xc8c <water_level+0x16>
        uint16_t adc = adc_read(h2o->bit);
        avg += adc;
    }
    return avg / 10;
     ca2:	ce 01       	movw	r24, r28
     ca4:	6a e0       	ldi	r22, 0x0A	; 10
     ca6:	70 e0       	ldi	r23, 0x00	; 0
     ca8:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <__divmodhi4>
     cac:	cb 01       	movw	r24, r22
}
     cae:	df 91       	pop	r29
     cb0:	cf 91       	pop	r28
     cb2:	1f 91       	pop	r17
     cb4:	0f 91       	pop	r16
     cb6:	ff 90       	pop	r15
     cb8:	ef 90       	pop	r14
     cba:	08 95       	ret

00000cbc <foodunit_drain>:

void foodunit_drain(foodunit* f) {
     cbc:	8f 92       	push	r8
     cbe:	9f 92       	push	r9
     cc0:	af 92       	push	r10
     cc2:	bf 92       	push	r11
     cc4:	cf 92       	push	r12
     cc6:	df 92       	push	r13
     cc8:	ef 92       	push	r14
     cca:	ff 92       	push	r15
     ccc:	0f 93       	push	r16
     cce:	1f 93       	push	r17
     cd0:	cf 93       	push	r28
     cd2:	df 93       	push	r29
     cd4:	cd b7       	in	r28, 0x3d	; 61
     cd6:	de b7       	in	r29, 0x3e	; 62
     cd8:	28 97       	sbiw	r28, 0x08	; 8
     cda:	0f b6       	in	r0, 0x3f	; 63
     cdc:	f8 94       	cli
     cde:	de bf       	out	0x3e, r29	; 62
     ce0:	0f be       	out	0x3f, r0	; 63
     ce2:	cd bf       	out	0x3d, r28	; 61
     ce4:	4c 01       	movw	r8, r24
    f->draining = true;
     ce6:	fc 01       	movw	r30, r24
     ce8:	eb 57       	subi	r30, 0x7B	; 123
     cea:	ff 4f       	sbci	r31, 0xFF	; 255
     cec:	81 e0       	ldi	r24, 0x01	; 1
     cee:	80 83       	st	Z, r24
    clear_pin(f->pump_relay);
     cf0:	f4 01       	movw	r30, r8
     cf2:	27 81       	ldd	r18, Z+7	; 0x07
     cf4:	30 85       	ldd	r19, Z+8	; 0x08
     cf6:	41 85       	ldd	r20, Z+9	; 0x09
     cf8:	52 85       	ldd	r21, Z+10	; 0x0a
     cfa:	63 85       	ldd	r22, Z+11	; 0x0b
     cfc:	74 85       	ldd	r23, Z+12	; 0x0c
     cfe:	85 85       	ldd	r24, Z+13	; 0x0d
     d00:	0e 94 82 0b 	call	0x1704	; 0x1704 <clear_pin>
    time to_drain = time_make(0, 0, f->drain_seconds, 0);
     d04:	f4 01       	movw	r30, r8
     d06:	ea 57       	subi	r30, 0x7A	; 122
     d08:	ff 4f       	sbci	r31, 0xFF	; 255
     d0a:	40 81       	ld	r20, Z
     d0c:	51 81       	ldd	r21, Z+1	; 0x01
     d0e:	20 e0       	ldi	r18, 0x00	; 0
     d10:	30 e0       	ldi	r19, 0x00	; 0
     d12:	60 e0       	ldi	r22, 0x00	; 0
     d14:	70 e0       	ldi	r23, 0x00	; 0
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	90 e0       	ldi	r25, 0x00	; 0
     d1a:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <time_make>
     d1e:	29 83       	std	Y+1, r18	; 0x01
     d20:	3a 83       	std	Y+2, r19	; 0x02
     d22:	4b 83       	std	Y+3, r20	; 0x03
     d24:	5c 83       	std	Y+4, r21	; 0x04
     d26:	6d 83       	std	Y+5, r22	; 0x05
     d28:	7e 83       	std	Y+6, r23	; 0x06
     d2a:	8f 83       	std	Y+7, r24	; 0x07
     d2c:	98 87       	std	Y+8, r25	; 0x08
    f->when_drain_ends = time_add(timer, to_drain);
     d2e:	f5 e7       	ldi	r31, 0x75	; 117
     d30:	8f 0e       	add	r8, r31
     d32:	91 1c       	adc	r9, r1
     d34:	59 01       	movw	r10, r18
     d36:	6a 01       	movw	r12, r20
     d38:	7b 01       	movw	r14, r22
     d3a:	8c 01       	movw	r16, r24
     d3c:	20 91 89 01 	lds	r18, 0x0189
     d40:	30 91 8a 01 	lds	r19, 0x018A
     d44:	40 91 8b 01 	lds	r20, 0x018B
     d48:	50 91 8c 01 	lds	r21, 0x018C
     d4c:	60 91 8d 01 	lds	r22, 0x018D
     d50:	70 91 8e 01 	lds	r23, 0x018E
     d54:	80 91 8f 01 	lds	r24, 0x018F
     d58:	90 91 90 01 	lds	r25, 0x0190
     d5c:	0e 94 a8 01 	call	0x350	; 0x350 <time_add>
     d60:	f4 01       	movw	r30, r8
     d62:	20 83       	st	Z, r18
     d64:	31 83       	std	Z+1, r19	; 0x01
     d66:	42 83       	std	Z+2, r20	; 0x02
     d68:	53 83       	std	Z+3, r21	; 0x03
     d6a:	64 83       	std	Z+4, r22	; 0x04
     d6c:	75 83       	std	Z+5, r23	; 0x05
     d6e:	86 83       	std	Z+6, r24	; 0x06
     d70:	97 83       	std	Z+7, r25	; 0x07
}
     d72:	28 96       	adiw	r28, 0x08	; 8
     d74:	0f b6       	in	r0, 0x3f	; 63
     d76:	f8 94       	cli
     d78:	de bf       	out	0x3e, r29	; 62
     d7a:	0f be       	out	0x3f, r0	; 63
     d7c:	cd bf       	out	0x3d, r28	; 61
     d7e:	df 91       	pop	r29
     d80:	cf 91       	pop	r28
     d82:	1f 91       	pop	r17
     d84:	0f 91       	pop	r16
     d86:	ff 90       	pop	r15
     d88:	ef 90       	pop	r14
     d8a:	df 90       	pop	r13
     d8c:	cf 90       	pop	r12
     d8e:	bf 90       	pop	r11
     d90:	af 90       	pop	r10
     d92:	9f 90       	pop	r9
     d94:	8f 90       	pop	r8
     d96:	08 95       	ret

00000d98 <foodunit_update_h2o_check>:

void foodunit_update_h2o_check(foodunit* f) {
     d98:	8f 92       	push	r8
     d9a:	9f 92       	push	r9
     d9c:	af 92       	push	r10
     d9e:	bf 92       	push	r11
     da0:	cf 92       	push	r12
     da2:	df 92       	push	r13
     da4:	ef 92       	push	r14
     da6:	ff 92       	push	r15
     da8:	0f 93       	push	r16
     daa:	1f 93       	push	r17
     dac:	cf 93       	push	r28
     dae:	df 93       	push	r29
     db0:	cd b7       	in	r28, 0x3d	; 61
     db2:	de b7       	in	r29, 0x3e	; 62
     db4:	28 97       	sbiw	r28, 0x08	; 8
     db6:	0f b6       	in	r0, 0x3f	; 63
     db8:	f8 94       	cli
     dba:	de bf       	out	0x3e, r29	; 62
     dbc:	0f be       	out	0x3f, r0	; 63
     dbe:	cd bf       	out	0x3d, r28	; 61
     dc0:	4c 01       	movw	r8, r24
    f->next_h2o_check = time_add(timer, time_make(0, 100, 0, 0));
     dc2:	20 e0       	ldi	r18, 0x00	; 0
     dc4:	30 e0       	ldi	r19, 0x00	; 0
     dc6:	40 e0       	ldi	r20, 0x00	; 0
     dc8:	50 e0       	ldi	r21, 0x00	; 0
     dca:	64 e6       	ldi	r22, 0x64	; 100
     dcc:	70 e0       	ldi	r23, 0x00	; 0
     dce:	80 e0       	ldi	r24, 0x00	; 0
     dd0:	90 e0       	ldi	r25, 0x00	; 0
     dd2:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <time_make>
     dd6:	29 83       	std	Y+1, r18	; 0x01
     dd8:	3a 83       	std	Y+2, r19	; 0x02
     dda:	4b 83       	std	Y+3, r20	; 0x03
     ddc:	5c 83       	std	Y+4, r21	; 0x04
     dde:	6d 83       	std	Y+5, r22	; 0x05
     de0:	7e 83       	std	Y+6, r23	; 0x06
     de2:	8f 83       	std	Y+7, r24	; 0x07
     de4:	98 87       	std	Y+8, r25	; 0x08
     de6:	ed e7       	ldi	r30, 0x7D	; 125
     de8:	8e 0e       	add	r8, r30
     dea:	91 1c       	adc	r9, r1
     dec:	59 01       	movw	r10, r18
     dee:	6a 01       	movw	r12, r20
     df0:	7b 01       	movw	r14, r22
     df2:	8c 01       	movw	r16, r24
     df4:	20 91 89 01 	lds	r18, 0x0189
     df8:	30 91 8a 01 	lds	r19, 0x018A
     dfc:	40 91 8b 01 	lds	r20, 0x018B
     e00:	50 91 8c 01 	lds	r21, 0x018C
     e04:	60 91 8d 01 	lds	r22, 0x018D
     e08:	70 91 8e 01 	lds	r23, 0x018E
     e0c:	80 91 8f 01 	lds	r24, 0x018F
     e10:	90 91 90 01 	lds	r25, 0x0190
     e14:	0e 94 a8 01 	call	0x350	; 0x350 <time_add>
     e18:	f4 01       	movw	r30, r8
     e1a:	20 83       	st	Z, r18
     e1c:	31 83       	std	Z+1, r19	; 0x01
     e1e:	42 83       	std	Z+2, r20	; 0x02
     e20:	53 83       	std	Z+3, r21	; 0x03
     e22:	64 83       	std	Z+4, r22	; 0x04
     e24:	75 83       	std	Z+5, r23	; 0x05
     e26:	86 83       	std	Z+6, r24	; 0x06
     e28:	97 83       	std	Z+7, r25	; 0x07
}
     e2a:	28 96       	adiw	r28, 0x08	; 8
     e2c:	0f b6       	in	r0, 0x3f	; 63
     e2e:	f8 94       	cli
     e30:	de bf       	out	0x3e, r29	; 62
     e32:	0f be       	out	0x3f, r0	; 63
     e34:	cd bf       	out	0x3d, r28	; 61
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	ff 90       	pop	r15
     e40:	ef 90       	pop	r14
     e42:	df 90       	pop	r13
     e44:	cf 90       	pop	r12
     e46:	bf 90       	pop	r11
     e48:	af 90       	pop	r10
     e4a:	9f 90       	pop	r9
     e4c:	8f 90       	pop	r8
     e4e:	08 95       	ret

00000e50 <foodunit_fill>:

void foodunit_fill(foodunit* f) {
     e50:	cf 93       	push	r28
     e52:	df 93       	push	r29
     e54:	ec 01       	movw	r28, r24
    f->draining = false;
     e56:	fc 01       	movw	r30, r24
     e58:	eb 57       	subi	r30, 0x7B	; 123
     e5a:	ff 4f       	sbci	r31, 0xFF	; 255
     e5c:	10 82       	st	Z, r1
    set_pin(f->pump_relay);
     e5e:	2f 81       	ldd	r18, Y+7	; 0x07
     e60:	38 85       	ldd	r19, Y+8	; 0x08
     e62:	49 85       	ldd	r20, Y+9	; 0x09
     e64:	5a 85       	ldd	r21, Y+10	; 0x0a
     e66:	6b 85       	ldd	r22, Y+11	; 0x0b
     e68:	7c 85       	ldd	r23, Y+12	; 0x0c
     e6a:	8d 85       	ldd	r24, Y+13	; 0x0d
     e6c:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <set_pin>
    foodunit_update_h2o_check(f);
     e70:	ce 01       	movw	r24, r28
}
     e72:	df 91       	pop	r29
     e74:	cf 91       	pop	r28
}

void foodunit_fill(foodunit* f) {
    f->draining = false;
    set_pin(f->pump_relay);
    foodunit_update_h2o_check(f);
     e76:	0c 94 cc 06 	jmp	0xd98	; 0xd98 <foodunit_update_h2o_check>

00000e7a <foodunit_update>:
}

void foodunit_update(foodunit* f) {
     e7a:	6f 92       	push	r6
     e7c:	7f 92       	push	r7
     e7e:	8f 92       	push	r8
     e80:	9f 92       	push	r9
     e82:	af 92       	push	r10
     e84:	bf 92       	push	r11
     e86:	cf 92       	push	r12
     e88:	df 92       	push	r13
     e8a:	ef 92       	push	r14
     e8c:	ff 92       	push	r15
     e8e:	0f 93       	push	r16
     e90:	1f 93       	push	r17
     e92:	cf 93       	push	r28
     e94:	df 93       	push	r29
     e96:	cd b7       	in	r28, 0x3d	; 61
     e98:	de b7       	in	r29, 0x3e	; 62
     e9a:	68 97       	sbiw	r28, 0x18	; 24
     e9c:	0f b6       	in	r0, 0x3f	; 63
     e9e:	f8 94       	cli
     ea0:	de bf       	out	0x3e, r29	; 62
     ea2:	0f be       	out	0x3f, r0	; 63
     ea4:	cd bf       	out	0x3d, r28	; 61
     ea6:	3c 01       	movw	r6, r24
    encoder_update(&f->enc);
     ea8:	84 5a       	subi	r24, 0xA4	; 164
     eaa:	9f 4f       	sbci	r25, 0xFF	; 255
     eac:	0e 94 97 08 	call	0x112e	; 0x112e <encoder_update>
    foodunit_display(f, f->screen);
     eb0:	f3 01       	movw	r30, r6
     eb2:	ec 58       	subi	r30, 0x8C	; 140
     eb4:	ff 4f       	sbci	r31, 0xFF	; 255
     eb6:	60 81       	ld	r22, Z
     eb8:	c3 01       	movw	r24, r6
     eba:	0e 94 b8 04 	call	0x970	; 0x970 <foodunit_display>
    
    if (f->draining) {
     ebe:	f3 01       	movw	r30, r6
     ec0:	eb 57       	subi	r30, 0x7B	; 123
     ec2:	ff 4f       	sbci	r31, 0xFF	; 255
     ec4:	80 81       	ld	r24, Z
     ec6:	88 23       	and	r24, r24
     ec8:	09 f4       	brne	.+2      	; 0xecc <foodunit_update+0x52>
     eca:	57 c0       	rjmp	.+174    	; 0xf7a <foodunit_update+0x100>
        if (time_is_greater(timer, f->when_drain_ends)) {
     ecc:	43 01       	movw	r8, r6
     ece:	85 e7       	ldi	r24, 0x75	; 117
     ed0:	88 0e       	add	r8, r24
     ed2:	91 1c       	adc	r9, r1
     ed4:	f4 01       	movw	r30, r8
     ed6:	a0 80       	ld	r10, Z
     ed8:	b1 80       	ldd	r11, Z+1	; 0x01
     eda:	c2 80       	ldd	r12, Z+2	; 0x02
     edc:	d3 80       	ldd	r13, Z+3	; 0x03
     ede:	e4 80       	ldd	r14, Z+4	; 0x04
     ee0:	f5 80       	ldd	r15, Z+5	; 0x05
     ee2:	06 81       	ldd	r16, Z+6	; 0x06
     ee4:	17 81       	ldd	r17, Z+7	; 0x07
     ee6:	20 91 89 01 	lds	r18, 0x0189
     eea:	30 91 8a 01 	lds	r19, 0x018A
     eee:	40 91 8b 01 	lds	r20, 0x018B
     ef2:	50 91 8c 01 	lds	r21, 0x018C
     ef6:	60 91 8d 01 	lds	r22, 0x018D
     efa:	70 91 8e 01 	lds	r23, 0x018E
     efe:	80 91 8f 01 	lds	r24, 0x018F
     f02:	90 91 90 01 	lds	r25, 0x0190
     f06:	0e 94 cb 00 	call	0x196	; 0x196 <time_is_greater>
     f0a:	88 23       	and	r24, r24
     f0c:	21 f0       	breq	.+8      	; 0xf16 <foodunit_update+0x9c>
            foodunit_fill(f);
     f0e:	c3 01       	movw	r24, r6
     f10:	0e 94 28 07 	call	0xe50	; 0xe50 <foodunit_fill>
     f14:	62 c0       	rjmp	.+196    	; 0xfda <foodunit_update+0x160>
        } else {
            // Update the drain display
            time t = time_diff(timer, f->when_drain_ends);
     f16:	f4 01       	movw	r30, r8
     f18:	a0 80       	ld	r10, Z
     f1a:	b1 80       	ldd	r11, Z+1	; 0x01
     f1c:	c2 80       	ldd	r12, Z+2	; 0x02
     f1e:	d3 80       	ldd	r13, Z+3	; 0x03
     f20:	e4 80       	ldd	r14, Z+4	; 0x04
     f22:	f5 80       	ldd	r15, Z+5	; 0x05
     f24:	06 81       	ldd	r16, Z+6	; 0x06
     f26:	17 81       	ldd	r17, Z+7	; 0x07
     f28:	20 91 89 01 	lds	r18, 0x0189
     f2c:	30 91 8a 01 	lds	r19, 0x018A
     f30:	40 91 8b 01 	lds	r20, 0x018B
     f34:	50 91 8c 01 	lds	r21, 0x018C
     f38:	60 91 8d 01 	lds	r22, 0x018D
     f3c:	70 91 8e 01 	lds	r23, 0x018E
     f40:	80 91 8f 01 	lds	r24, 0x018F
     f44:	90 91 90 01 	lds	r25, 0x0190
     f48:	0e 94 de 02 	call	0x5bc	; 0x5bc <time_diff>
            char t1[16];
            time_str(t1, t);
     f4c:	89 01       	movw	r16, r18
     f4e:	9a 01       	movw	r18, r20
     f50:	ab 01       	movw	r20, r22
     f52:	bc 01       	movw	r22, r24
     f54:	ce 01       	movw	r24, r28
     f56:	01 96       	adiw	r24, 0x01	; 1
     f58:	0e 94 5e 03 	call	0x6bc	; 0x6bc <time_str>
            lcd_xy(&f->lcd, 0, 1);
     f5c:	fe e0       	ldi	r31, 0x0E	; 14
     f5e:	6f 0e       	add	r6, r31
     f60:	71 1c       	adc	r7, r1
     f62:	41 e0       	ldi	r20, 0x01	; 1
     f64:	60 e0       	ldi	r22, 0x00	; 0
     f66:	c3 01       	movw	r24, r6
     f68:	0e 94 2f 0b 	call	0x165e	; 0x165e <lcd_xy>
            lcd_write(&f->lcd, t1);
     f6c:	be 01       	movw	r22, r28
     f6e:	6f 5f       	subi	r22, 0xFF	; 255
     f70:	7f 4f       	sbci	r23, 0xFF	; 255
     f72:	c3 01       	movw	r24, r6
     f74:	0e 94 0a 0b 	call	0x1614	; 0x1614 <lcd_write>
     f78:	30 c0       	rjmp	.+96     	; 0xfda <foodunit_update+0x160>
        }
    } else {
        if (time_is_greater(timer, f->next_h2o_check)){
     f7a:	f3 01       	movw	r30, r6
     f7c:	e3 58       	subi	r30, 0x83	; 131
     f7e:	ff 4f       	sbci	r31, 0xFF	; 255
     f80:	a0 80       	ld	r10, Z
     f82:	b1 80       	ldd	r11, Z+1	; 0x01
     f84:	c2 80       	ldd	r12, Z+2	; 0x02
     f86:	d3 80       	ldd	r13, Z+3	; 0x03
     f88:	e4 80       	ldd	r14, Z+4	; 0x04
     f8a:	f5 80       	ldd	r15, Z+5	; 0x05
     f8c:	06 81       	ldd	r16, Z+6	; 0x06
     f8e:	17 81       	ldd	r17, Z+7	; 0x07
     f90:	20 91 89 01 	lds	r18, 0x0189
     f94:	30 91 8a 01 	lds	r19, 0x018A
     f98:	40 91 8b 01 	lds	r20, 0x018B
     f9c:	50 91 8c 01 	lds	r21, 0x018C
     fa0:	60 91 8d 01 	lds	r22, 0x018D
     fa4:	70 91 8e 01 	lds	r23, 0x018E
     fa8:	80 91 8f 01 	lds	r24, 0x018F
     fac:	90 91 90 01 	lds	r25, 0x0190
     fb0:	0e 94 cb 00 	call	0x196	; 0x196 <time_is_greater>
     fb4:	88 23       	and	r24, r24
     fb6:	89 f0       	breq	.+34     	; 0xfda <foodunit_update+0x160>
            foodunit_update_h2o_check(f);
     fb8:	c3 01       	movw	r24, r6
     fba:	0e 94 cc 06 	call	0xd98	; 0xd98 <foodunit_update_h2o_check>
            uint16_t lvl = water_level(&f->h2o_sensor);
     fbe:	c3 01       	movw	r24, r6
     fc0:	0e 94 3b 06 	call	0xc76	; 0xc76 <water_level>
            if (lvl < f->h2o_threshold) {
     fc4:	f3 01       	movw	r30, r6
     fc6:	e8 57       	subi	r30, 0x78	; 120
     fc8:	ff 4f       	sbci	r31, 0xFF	; 255
     fca:	20 81       	ld	r18, Z
     fcc:	31 81       	ldd	r19, Z+1	; 0x01
     fce:	82 17       	cp	r24, r18
     fd0:	93 07       	cpc	r25, r19
     fd2:	18 f4       	brcc	.+6      	; 0xfda <foodunit_update+0x160>
                foodunit_drain(f);
     fd4:	c3 01       	movw	r24, r6
     fd6:	0e 94 5e 06 	call	0xcbc	; 0xcbc <foodunit_drain>
            }
        }
    }
    
}
     fda:	68 96       	adiw	r28, 0x18	; 24
     fdc:	0f b6       	in	r0, 0x3f	; 63
     fde:	f8 94       	cli
     fe0:	de bf       	out	0x3e, r29	; 62
     fe2:	0f be       	out	0x3f, r0	; 63
     fe4:	cd bf       	out	0x3d, r28	; 61
     fe6:	df 91       	pop	r29
     fe8:	cf 91       	pop	r28
     fea:	1f 91       	pop	r17
     fec:	0f 91       	pop	r16
     fee:	ff 90       	pop	r15
     ff0:	ef 90       	pop	r14
     ff2:	df 90       	pop	r13
     ff4:	cf 90       	pop	r12
     ff6:	bf 90       	pop	r11
     ff8:	af 90       	pop	r10
     ffa:	9f 90       	pop	r9
     ffc:	8f 90       	pop	r8
     ffe:	7f 90       	pop	r7
    1000:	6f 90       	pop	r6
    1002:	08 95       	ret

00001004 <analogReference>:
static uint8_t aref = (1<<REFS0); // default to AREF = Vcc


void analogReference(uint8_t mode)
{
	aref = mode & 0xC0;
    1004:	80 7c       	andi	r24, 0xC0	; 192
    1006:	80 93 00 01 	sts	0x0100, r24
    100a:	08 95       	ret

0000100c <adc_read>:
#if defined(__AVR_AT90USB162__)
	return 0;
#else
	uint8_t low;

	ADCSRA = (1<<ADEN) | ADC_PRESCALER;		// enable ADC
    100c:	96 e8       	ldi	r25, 0x86	; 134
    100e:	90 93 7a 00 	sts	0x007A, r25
	ADCSRB = (1<<ADHSM) | (mux & 0x20);		// high speed mode
    1012:	98 2f       	mov	r25, r24
    1014:	90 72       	andi	r25, 0x20	; 32
    1016:	90 68       	ori	r25, 0x80	; 128
    1018:	90 93 7b 00 	sts	0x007B, r25
	ADMUX = aref | (mux & 0x1F);			// configure mux input
    101c:	8f 71       	andi	r24, 0x1F	; 31
    101e:	90 91 00 01 	lds	r25, 0x0100
    1022:	89 2b       	or	r24, r25
    1024:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = (1<<ADEN) | ADC_PRESCALER | (1<<ADSC);	// start the conversion
    1028:	86 ec       	ldi	r24, 0xC6	; 198
    102a:	80 93 7a 00 	sts	0x007A, r24
	while (ADCSRA & (1<<ADSC)) ;			// wait for result
    102e:	80 91 7a 00 	lds	r24, 0x007A
    1032:	86 fd       	sbrc	r24, 6
    1034:	fc cf       	rjmp	.-8      	; 0x102e <adc_read+0x22>
	low = ADCL;					// must read LSB first
    1036:	80 91 78 00 	lds	r24, 0x0078
	return (ADCH << 8) | low;			// must read MSB only once!
    103a:	20 91 79 00 	lds	r18, 0x0079
    103e:	90 e0       	ldi	r25, 0x00	; 0
#endif
}
    1040:	92 2b       	or	r25, r18
    1042:	08 95       	ret

00001044 <analogRead>:
		0x00, 0x01, 0x04, 0x05, 0x06, 0x07,
		0x25, 0x24, 0x23, 0x22, 0x21, 0x20};
	if (pin >= 12) return 0;
	return adc_read(pgm_read_byte(pin_to_mux + pin));
#elif defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__)
	if (pin >= 8) return 0;
    1044:	88 30       	cpi	r24, 0x08	; 8
    1046:	10 f4       	brcc	.+4      	; 0x104c <analogRead+0x8>
	return adc_read(pin);
    1048:	0c 94 06 08 	jmp	0x100c	; 0x100c <adc_read>
#else
	return 0;
#endif
}
    104c:	80 e0       	ldi	r24, 0x00	; 0
    104e:	90 e0       	ldi	r25, 0x00	; 0
    1050:	08 95       	ret

00001052 <encoder_init>:
static const int8_t enc_states[] = {0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0};
static const uint8_t enc_edge_up = 0x01;
static const uint8_t enc_edge_down = 0xFE;
static const uint8_t enc_up = 0xFF;

void encoder_init(encoder* enc) {
    1052:	cf 93       	push	r28
    1054:	df 93       	push	r29
    1056:	ec 01       	movw	r28, r24
    // Set btn to read a pushbutton
    input_pin(enc->btn);
    1058:	2e 85       	ldd	r18, Y+14	; 0x0e
    105a:	3f 85       	ldd	r19, Y+15	; 0x0f
    105c:	48 89       	ldd	r20, Y+16	; 0x10
    105e:	59 89       	ldd	r21, Y+17	; 0x11
    1060:	6a 89       	ldd	r22, Y+18	; 0x12
    1062:	7b 89       	ldd	r23, Y+19	; 0x13
    1064:	8c 89       	ldd	r24, Y+20	; 0x14
    1066:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <input_pin>
    set_pin(enc->btn);
    106a:	2e 85       	ldd	r18, Y+14	; 0x0e
    106c:	3f 85       	ldd	r19, Y+15	; 0x0f
    106e:	48 89       	ldd	r20, Y+16	; 0x10
    1070:	59 89       	ldd	r21, Y+17	; 0x11
    1072:	6a 89       	ldd	r22, Y+18	; 0x12
    1074:	7b 89       	ldd	r23, Y+19	; 0x13
    1076:	8c 89       	ldd	r24, Y+20	; 0x14
    1078:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <set_pin>
    
    // Set a and b to the rotary encoder gray code inputs
    // Use the tutorial to read gray code
    // @see http://www.circuitsathome.com/mcu/programming/reading-rotary-encoder-on-arduino
    input_pin(enc->a);
    107c:	28 81       	ld	r18, Y
    107e:	39 81       	ldd	r19, Y+1	; 0x01
    1080:	4a 81       	ldd	r20, Y+2	; 0x02
    1082:	5b 81       	ldd	r21, Y+3	; 0x03
    1084:	6c 81       	ldd	r22, Y+4	; 0x04
    1086:	7d 81       	ldd	r23, Y+5	; 0x05
    1088:	8e 81       	ldd	r24, Y+6	; 0x06
    108a:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <input_pin>
    set_pin(enc->a);
    108e:	28 81       	ld	r18, Y
    1090:	39 81       	ldd	r19, Y+1	; 0x01
    1092:	4a 81       	ldd	r20, Y+2	; 0x02
    1094:	5b 81       	ldd	r21, Y+3	; 0x03
    1096:	6c 81       	ldd	r22, Y+4	; 0x04
    1098:	7d 81       	ldd	r23, Y+5	; 0x05
    109a:	8e 81       	ldd	r24, Y+6	; 0x06
    109c:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <set_pin>
    input_pin(enc->b);
    10a0:	2f 81       	ldd	r18, Y+7	; 0x07
    10a2:	38 85       	ldd	r19, Y+8	; 0x08
    10a4:	49 85       	ldd	r20, Y+9	; 0x09
    10a6:	5a 85       	ldd	r21, Y+10	; 0x0a
    10a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    10aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    10ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    10ae:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <input_pin>
    set_pin(enc->b);
    10b2:	2f 81       	ldd	r18, Y+7	; 0x07
    10b4:	38 85       	ldd	r19, Y+8	; 0x08
    10b6:	49 85       	ldd	r20, Y+9	; 0x09
    10b8:	5a 85       	ldd	r21, Y+10	; 0x0a
    10ba:	6b 85       	ldd	r22, Y+11	; 0x0b
    10bc:	7c 85       	ldd	r23, Y+12	; 0x0c
    10be:	8d 85       	ldd	r24, Y+13	; 0x0d
    10c0:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <set_pin>
    encoder_clear(enc);
    
}

void encoder_clear(encoder* enc) {
    enc->val = 0;
    10c4:	1d 8a       	std	Y+21, r1	; 0x15
    enc->steps = 0;
    10c6:	1f 8a       	std	Y+23, r1	; 0x17
    enc->btn_val = enc_up;
    10c8:	8f ef       	ldi	r24, 0xFF	; 255
    10ca:	8e 8b       	std	Y+22, r24	; 0x16
    input_pin(enc->b);
    set_pin(enc->b);
    
    encoder_clear(enc);
    
}
    10cc:	df 91       	pop	r29
    10ce:	cf 91       	pop	r28
    10d0:	08 95       	ret

000010d2 <encoder_clear>:

void encoder_clear(encoder* enc) {
    10d2:	fc 01       	movw	r30, r24
    enc->val = 0;
    10d4:	15 8a       	std	Z+21, r1	; 0x15
    enc->steps = 0;
    10d6:	17 8a       	std	Z+23, r1	; 0x17
    enc->btn_val = enc_up;
    10d8:	8f ef       	ldi	r24, 0xFF	; 255
    10da:	86 8b       	std	Z+22, r24	; 0x16
    10dc:	08 95       	ret

000010de <encoder_get_step>:
}

int8_t encoder_get_step(encoder* enc) {
    10de:	1f 93       	push	r17
    10e0:	cf 93       	push	r28
    10e2:	df 93       	push	r29
    10e4:	ec 01       	movw	r28, r24
    // Handle the rotary gray code.
    uint8_t a = read_pin(enc->a);
    10e6:	28 81       	ld	r18, Y
    10e8:	39 81       	ldd	r19, Y+1	; 0x01
    10ea:	4a 81       	ldd	r20, Y+2	; 0x02
    10ec:	5b 81       	ldd	r21, Y+3	; 0x03
    10ee:	6c 81       	ldd	r22, Y+4	; 0x04
    10f0:	7d 81       	ldd	r23, Y+5	; 0x05
    10f2:	8e 81       	ldd	r24, Y+6	; 0x06
    10f4:	0e 94 aa 0b 	call	0x1754	; 0x1754 <read_pin>
    10f8:	18 2f       	mov	r17, r24
    uint8_t b = read_pin(enc->b);
    10fa:	2f 81       	ldd	r18, Y+7	; 0x07
    10fc:	38 85       	ldd	r19, Y+8	; 0x08
    10fe:	49 85       	ldd	r20, Y+9	; 0x09
    1100:	5a 85       	ldd	r21, Y+10	; 0x0a
    1102:	6b 85       	ldd	r22, Y+11	; 0x0b
    1104:	7c 85       	ldd	r23, Y+12	; 0x0c
    1106:	8d 85       	ldd	r24, Y+13	; 0x0d
    1108:	0e 94 aa 0b 	call	0x1754	; 0x1754 <read_pin>
    
    enc->val <<= 2;
    110c:	9d 89       	ldd	r25, Y+21	; 0x15
    110e:	99 0f       	add	r25, r25
    1110:	99 0f       	add	r25, r25
    enc->val |= (a << 1) | b;
    1112:	98 2b       	or	r25, r24
    1114:	e1 2f       	mov	r30, r17
    1116:	ee 0f       	add	r30, r30
    1118:	e9 2b       	or	r30, r25
    111a:	ed 8b       	std	Y+21, r30	; 0x15
    
    return enc_states[enc->val & 0x0f];
    111c:	ef 70       	andi	r30, 0x0F	; 15
    111e:	f0 e0       	ldi	r31, 0x00	; 0
    1120:	ef 5f       	subi	r30, 0xFF	; 255
    1122:	fe 4f       	sbci	r31, 0xFE	; 254
}
    1124:	80 81       	ld	r24, Z
    1126:	df 91       	pop	r29
    1128:	cf 91       	pop	r28
    112a:	1f 91       	pop	r17
    112c:	08 95       	ret

0000112e <encoder_update>:

void encoder_update(encoder* e) {
    112e:	1f 93       	push	r17
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	ec 01       	movw	r28, r24
    e->steps += encoder_get_step(e);
    1136:	1f 89       	ldd	r17, Y+23	; 0x17
    1138:	0e 94 6f 08 	call	0x10de	; 0x10de <encoder_get_step>
    113c:	81 0f       	add	r24, r17
    113e:	8f 8b       	std	Y+23, r24	; 0x17
    e->btn_val <<= 1;
    1140:	1e 89       	ldd	r17, Y+22	; 0x16
    1142:	11 0f       	add	r17, r17
    1144:	1e 8b       	std	Y+22, r17	; 0x16
    e->btn_val |= read_pin(e->btn);
    1146:	2e 85       	ldd	r18, Y+14	; 0x0e
    1148:	3f 85       	ldd	r19, Y+15	; 0x0f
    114a:	48 89       	ldd	r20, Y+16	; 0x10
    114c:	59 89       	ldd	r21, Y+17	; 0x11
    114e:	6a 89       	ldd	r22, Y+18	; 0x12
    1150:	7b 89       	ldd	r23, Y+19	; 0x13
    1152:	8c 89       	ldd	r24, Y+20	; 0x14
    1154:	0e 94 aa 0b 	call	0x1754	; 0x1754 <read_pin>
    1158:	81 2b       	or	r24, r17
    115a:	8e 8b       	std	Y+22, r24	; 0x16
}
    115c:	df 91       	pop	r29
    115e:	cf 91       	pop	r28
    1160:	1f 91       	pop	r17
    1162:	08 95       	ret

00001164 <encoder_btn_down>:

bool encoder_btn_down(encoder* e) {
    return e->btn_val & 0x01;
    1164:	fc 01       	movw	r30, r24
    1166:	86 89       	ldd	r24, Z+22	; 0x16
}
    1168:	81 70       	andi	r24, 0x01	; 1
    116a:	08 95       	ret

0000116c <encoder_btn_up>:
    e->btn_val <<= 1;
    e->btn_val |= read_pin(e->btn);
}

bool encoder_btn_down(encoder* e) {
    return e->btn_val & 0x01;
    116c:	fc 01       	movw	r30, r24
    116e:	86 89       	ldd	r24, Z+22	; 0x16
    1170:	80 95       	com	r24
}

bool encoder_btn_up(encoder* e) {
    return !encoder_btn_down(e);
}
    1172:	81 70       	andi	r24, 0x01	; 1
    1174:	08 95       	ret

00001176 <encoder_btn_down_edge>:

bool encoder_btn_down_edge(encoder* e) {
    return (e->btn_val == enc_edge_down);
    1176:	21 e0       	ldi	r18, 0x01	; 1
    1178:	fc 01       	movw	r30, r24
    117a:	86 89       	ldd	r24, Z+22	; 0x16
    117c:	8e 3f       	cpi	r24, 0xFE	; 254
    117e:	09 f0       	breq	.+2      	; 0x1182 <encoder_btn_down_edge+0xc>
    1180:	20 e0       	ldi	r18, 0x00	; 0
}
    1182:	82 2f       	mov	r24, r18
    1184:	08 95       	ret

00001186 <encoder_btn_up_edge>:

bool encoder_btn_up_edge(encoder* e) {
    return (e->btn_val == enc_edge_up);
    1186:	21 e0       	ldi	r18, 0x01	; 1
    1188:	fc 01       	movw	r30, r24
    118a:	86 89       	ldd	r24, Z+22	; 0x16
    118c:	81 30       	cpi	r24, 0x01	; 1
    118e:	09 f0       	breq	.+2      	; 0x1192 <encoder_btn_up_edge+0xc>
    1190:	20 e0       	ldi	r18, 0x00	; 0
    1192:	82 2f       	mov	r24, r18
    1194:	08 95       	ret

00001196 <flip_bit>:
#include <util/delay.h>
#include "lcd.h"


// Flips a flag at a bit position either on or off.
void flip_bit(uint8_t* val, uint8_t bit, bool high) {
    1196:	fc 01       	movw	r30, r24
    1198:	20 81       	ld	r18, Z
    if (high) {
        *val |= _BV(bit);
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	06 2e       	mov	r0, r22
    11a0:	01 c0       	rjmp	.+2      	; 0x11a4 <flip_bit+0xe>
    11a2:	88 0f       	add	r24, r24
    11a4:	0a 94       	dec	r0
    11a6:	ea f7       	brpl	.-6      	; 0x11a2 <flip_bit+0xc>
#include "lcd.h"


// Flips a flag at a bit position either on or off.
void flip_bit(uint8_t* val, uint8_t bit, bool high) {
    if (high) {
    11a8:	44 23       	and	r20, r20
    11aa:	11 f0       	breq	.+4      	; 0x11b0 <flip_bit+0x1a>
        *val |= _BV(bit);
    11ac:	82 2b       	or	r24, r18
    11ae:	02 c0       	rjmp	.+4      	; 0x11b4 <flip_bit+0x1e>
    } else {
        *val &= ~_BV(bit);
    11b0:	80 95       	com	r24
    11b2:	82 23       	and	r24, r18
    11b4:	80 83       	st	Z, r24
    11b6:	08 95       	ret

000011b8 <lcd_function_set_flags>:
 Note: Perform the function at the head of the program before executing any 
 instructions (except for the read busy flag and address instruction). From this 
 point, the function set instruction cannot be executed unless the interface 
 data length is changed.
 */
uint8_t lcd_function_set_flags(bool dl, bool n, bool f) {
    11b8:	0f 93       	push	r16
    11ba:	1f 93       	push	r17
    11bc:	cf 93       	push	r28
    11be:	df 93       	push	r29
    11c0:	1f 92       	push	r1
    11c2:	cd b7       	in	r28, 0x3d	; 61
    11c4:	de b7       	in	r29, 0x3e	; 62
    11c6:	06 2f       	mov	r16, r22
    11c8:	14 2f       	mov	r17, r20


// Flips a flag at a bit position either on or off.
void flip_bit(uint8_t* val, uint8_t bit, bool high) {
    if (high) {
        *val |= _BV(bit);
    11ca:	90 e2       	ldi	r25, 0x20	; 32
    11cc:	99 83       	std	Y+1, r25	; 0x01
 data length is changed.
 */
uint8_t lcd_function_set_flags(bool dl, bool n, bool f) {
    uint8_t flags = 0;
    flip_bit(&flags, 5, 1);
    flip_bit(&flags, 4, dl);
    11ce:	48 2f       	mov	r20, r24
    11d0:	64 e0       	ldi	r22, 0x04	; 4
    11d2:	ce 01       	movw	r24, r28
    11d4:	01 96       	adiw	r24, 0x01	; 1
    11d6:	0e 94 cb 08 	call	0x1196	; 0x1196 <flip_bit>
    flip_bit(&flags, 3, n);
    11da:	40 2f       	mov	r20, r16
    11dc:	63 e0       	ldi	r22, 0x03	; 3
    11de:	ce 01       	movw	r24, r28
    11e0:	01 96       	adiw	r24, 0x01	; 1
    11e2:	0e 94 cb 08 	call	0x1196	; 0x1196 <flip_bit>
    flip_bit(&flags, 2, f);
    11e6:	41 2f       	mov	r20, r17
    11e8:	62 e0       	ldi	r22, 0x02	; 2
    11ea:	ce 01       	movw	r24, r28
    11ec:	01 96       	adiw	r24, 0x01	; 1
    11ee:	0e 94 cb 08 	call	0x1196	; 0x1196 <flip_bit>
    return flags;
}
    11f2:	89 81       	ldd	r24, Y+1	; 0x01
    11f4:	0f 90       	pop	r0
    11f6:	df 91       	pop	r29
    11f8:	cf 91       	pop	r28
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	08 95       	ret

00001200 <lcd_display_toggle_flags>:
    characters at a speed of 409.6-ms intervals when fcp or fOSC is 250 kHz. 
    The cursor and blinking can be set to display simultaneously. (The blinking 
    frequency changes according to fOSC or the reciprocal of fcp. For example, 
    when fcp is 270 kHz, 409.6  250/270 = 379.2 ms.)
 */
uint8_t lcd_display_toggle_flags(bool d, bool c, bool b) {
    1200:	0f 93       	push	r16
    1202:	1f 93       	push	r17
    1204:	cf 93       	push	r28
    1206:	df 93       	push	r29
    1208:	1f 92       	push	r1
    120a:	cd b7       	in	r28, 0x3d	; 61
    120c:	de b7       	in	r29, 0x3e	; 62
    120e:	06 2f       	mov	r16, r22
    1210:	14 2f       	mov	r17, r20


// Flips a flag at a bit position either on or off.
void flip_bit(uint8_t* val, uint8_t bit, bool high) {
    if (high) {
        *val |= _BV(bit);
    1212:	98 e0       	ldi	r25, 0x08	; 8
    1214:	99 83       	std	Y+1, r25	; 0x01
    when fcp is 270 kHz, 409.6  250/270 = 379.2 ms.)
 */
uint8_t lcd_display_toggle_flags(bool d, bool c, bool b) {
    uint8_t flags = 0;
    flip_bit(&flags, 3, 1);
    flip_bit(&flags, 2, d);
    1216:	48 2f       	mov	r20, r24
    1218:	62 e0       	ldi	r22, 0x02	; 2
    121a:	ce 01       	movw	r24, r28
    121c:	01 96       	adiw	r24, 0x01	; 1
    121e:	0e 94 cb 08 	call	0x1196	; 0x1196 <flip_bit>
    flip_bit(&flags, 1, c);
    1222:	40 2f       	mov	r20, r16
    1224:	61 e0       	ldi	r22, 0x01	; 1
    1226:	ce 01       	movw	r24, r28
    1228:	01 96       	adiw	r24, 0x01	; 1
    122a:	0e 94 cb 08 	call	0x1196	; 0x1196 <flip_bit>
    flip_bit(&flags, 0, b);
    122e:	41 2f       	mov	r20, r17
    1230:	60 e0       	ldi	r22, 0x00	; 0
    1232:	ce 01       	movw	r24, r28
    1234:	01 96       	adiw	r24, 0x01	; 1
    1236:	0e 94 cb 08 	call	0x1196	; 0x1196 <flip_bit>
    return flags;
}
    123a:	89 81       	ldd	r24, Y+1	; 0x01
    123c:	0f 90       	pop	r0
    123e:	df 91       	pop	r29
    1240:	cf 91       	pop	r28
    1242:	1f 91       	pop	r17
    1244:	0f 91       	pop	r16
    1246:	08 95       	ret

00001248 <lcd_display_clear_flags>:
 displayed). It also sets I/D to 1 (increment mode) in entry mode. S of entry 
 mode does not change.
 */
uint8_t lcd_display_clear_flags(void) {
    return 1;
}
    1248:	81 e0       	ldi	r24, 0x01	; 1
    124a:	08 95       	ret

0000124c <lcd_entry_mode_set_flags>:
    (I/D = 1) when S is 1. The display does not shift if S is 0.
    If S is 1, it will seem as if the cursor does not move but the display does. 
    The display does not shift when reading from DDRAM. Also, writing into or 
    reading out from CGRAM does not shift the display.
 */
uint8_t lcd_entry_mode_set_flags(bool id, bool s) {
    124c:	1f 93       	push	r17
    124e:	cf 93       	push	r28
    1250:	df 93       	push	r29
    1252:	1f 92       	push	r1
    1254:	cd b7       	in	r28, 0x3d	; 61
    1256:	de b7       	in	r29, 0x3e	; 62
    1258:	16 2f       	mov	r17, r22


// Flips a flag at a bit position either on or off.
void flip_bit(uint8_t* val, uint8_t bit, bool high) {
    if (high) {
        *val |= _BV(bit);
    125a:	94 e0       	ldi	r25, 0x04	; 4
    125c:	99 83       	std	Y+1, r25	; 0x01
    reading out from CGRAM does not shift the display.
 */
uint8_t lcd_entry_mode_set_flags(bool id, bool s) {
    uint8_t flags = 0;
    flip_bit(&flags, 2, 1);
    flip_bit(&flags, 1, id);
    125e:	48 2f       	mov	r20, r24
    1260:	61 e0       	ldi	r22, 0x01	; 1
    1262:	ce 01       	movw	r24, r28
    1264:	01 96       	adiw	r24, 0x01	; 1
    1266:	0e 94 cb 08 	call	0x1196	; 0x1196 <flip_bit>
    flip_bit(&flags, 0, s);
    126a:	41 2f       	mov	r20, r17
    126c:	60 e0       	ldi	r22, 0x00	; 0
    126e:	ce 01       	movw	r24, r28
    1270:	01 96       	adiw	r24, 0x01	; 1
    1272:	0e 94 cb 08 	call	0x1196	; 0x1196 <flip_bit>
    return flags;
}
    1276:	89 81       	ldd	r24, Y+1	; 0x01
    1278:	0f 90       	pop	r0
    127a:	df 91       	pop	r29
    127c:	cf 91       	pop	r28
    127e:	1f 91       	pop	r17
    1280:	08 95       	ret

00001282 <lcd_return_home_flags>:

uint8_t lcd_return_home_flags(void) {
    uint8_t flags = 0;
    flip_bit(&flags, 1, 1);
    return flags;
}
    1282:	82 e0       	ldi	r24, 0x02	; 2
    1284:	08 95       	ret

00001286 <lcd_set_ddram_addr>:
 AAAAAAA can be 00H to 27H for the first line, and 40H to 67H for the second line.
 */
uint8_t lcd_set_ddram_addr(uint8_t address) {
    uint8_t flags = 0x80 + address;
    return flags;
}
    1286:	80 58       	subi	r24, 0x80	; 128
    1288:	08 95       	ret

0000128a <lcd_select_register>:

/** Selects between the instruction (command) and data registers on the given
 lcd.
 */
void lcd_select_register(hd44780 *lcd, bool selected_register) {
    128a:	fc 01       	movw	r30, r24
    if (selected_register == LCD_COMMAND_REGISTER) {
        //clear_bit(PORTD, 7);
        clear_pin(lcd->rs);
    128c:	20 81       	ld	r18, Z
    128e:	31 81       	ldd	r19, Z+1	; 0x01
    1290:	42 81       	ldd	r20, Z+2	; 0x02
    1292:	53 81       	ldd	r21, Z+3	; 0x03

/** Selects between the instruction (command) and data registers on the given
 lcd.
 */
void lcd_select_register(hd44780 *lcd, bool selected_register) {
    if (selected_register == LCD_COMMAND_REGISTER) {
    1294:	61 11       	cpse	r22, r1
    1296:	05 c0       	rjmp	.+10     	; 0x12a2 <lcd_select_register+0x18>
        //clear_bit(PORTD, 7);
        clear_pin(lcd->rs);
    1298:	64 81       	ldd	r22, Z+4	; 0x04
    129a:	75 81       	ldd	r23, Z+5	; 0x05
    129c:	86 81       	ldd	r24, Z+6	; 0x06
    129e:	0c 94 82 0b 	jmp	0x1704	; 0x1704 <clear_pin>
    } else {
        //set_bit(PORTD, 7);
        set_pin(lcd->rs);
    12a2:	64 81       	ldd	r22, Z+4	; 0x04
    12a4:	75 81       	ldd	r23, Z+5	; 0x05
    12a6:	86 81       	ldd	r24, Z+6	; 0x06
    12a8:	0c 94 5b 0b 	jmp	0x16b6	; 0x16b6 <set_pin>

000012ac <lcd_toggle_send_register>:
    }
}

void lcd_toggle_send_register(hd44780* lcd, bool lcd_register) {
    12ac:	1f 93       	push	r17
    12ae:	cf 93       	push	r28
    12b0:	df 93       	push	r29
    12b2:	ec 01       	movw	r28, r24
    12b4:	16 2f       	mov	r17, r22
    // Set the E wire
    set_pin(lcd->e);
    12b6:	2e 85       	ldd	r18, Y+14	; 0x0e
    12b8:	3f 85       	ldd	r19, Y+15	; 0x0f
    12ba:	48 89       	ldd	r20, Y+16	; 0x10
    12bc:	59 89       	ldd	r21, Y+17	; 0x11
    12be:	6a 89       	ldd	r22, Y+18	; 0x12
    12c0:	7b 89       	ldd	r23, Y+19	; 0x13
    12c2:	8c 89       	ldd	r24, Y+20	; 0x14
    12c4:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <set_pin>
    // Select register
    lcd_select_register(lcd, lcd_register);
    12c8:	61 2f       	mov	r22, r17
    12ca:	ce 01       	movw	r24, r28
    12cc:	0e 94 45 09 	call	0x128a	; 0x128a <lcd_select_register>
    // Set RW to write
    clear_pin(lcd->rw);
    12d0:	2f 81       	ldd	r18, Y+7	; 0x07
    12d2:	38 85       	ldd	r19, Y+8	; 0x08
    12d4:	49 85       	ldd	r20, Y+9	; 0x09
    12d6:	5a 85       	ldd	r21, Y+10	; 0x0a
    12d8:	6b 85       	ldd	r22, Y+11	; 0x0b
    12da:	7c 85       	ldd	r23, Y+12	; 0x0c
    12dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    12de:	0e 94 82 0b 	call	0x1704	; 0x1704 <clear_pin>
    // Clear E
    clear_pin(lcd->e);
    12e2:	2e 85       	ldd	r18, Y+14	; 0x0e
    12e4:	3f 85       	ldd	r19, Y+15	; 0x0f
    12e6:	48 89       	ldd	r20, Y+16	; 0x10
    12e8:	59 89       	ldd	r21, Y+17	; 0x11
    12ea:	6a 89       	ldd	r22, Y+18	; 0x12
    12ec:	7b 89       	ldd	r23, Y+19	; 0x13
    12ee:	8c 89       	ldd	r24, Y+20	; 0x14
    12f0:	0e 94 82 0b 	call	0x1704	; 0x1704 <clear_pin>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    12f4:	8f ed       	ldi	r24, 0xDF	; 223
    12f6:	9e e2       	ldi	r25, 0x2E	; 46
    12f8:	01 97       	sbiw	r24, 0x01	; 1
    12fa:	f1 f7       	brne	.-4      	; 0x12f8 <lcd_toggle_send_register+0x4c>
    12fc:	00 c0       	rjmp	.+0      	; 0x12fe <lcd_toggle_send_register+0x52>
    12fe:	00 00       	nop
    // Wait a bit
    _delay_ms(3);
}
    1300:	df 91       	pop	r29
    1302:	cf 91       	pop	r28
    1304:	1f 91       	pop	r17
    1306:	08 95       	ret

00001308 <pin_set_bit>:

void pin_set_bit(pin p, bool high) {
    1308:	0f 93       	push	r16
    130a:	cf 93       	push	r28
    130c:	df 93       	push	r29
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	27 97       	sbiw	r28, 0x07	; 7
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	de bf       	out	0x3e, r29	; 62
    131a:	0f be       	out	0x3f, r0	; 63
    131c:	cd bf       	out	0x3d, r28	; 61
    131e:	29 83       	std	Y+1, r18	; 0x01
    1320:	3a 83       	std	Y+2, r19	; 0x02
    1322:	4b 83       	std	Y+3, r20	; 0x03
    1324:	5c 83       	std	Y+4, r21	; 0x04
    1326:	6d 83       	std	Y+5, r22	; 0x05
    1328:	7e 83       	std	Y+6, r23	; 0x06
    132a:	8f 83       	std	Y+7, r24	; 0x07
    if (high) {
    132c:	00 23       	and	r16, r16
    132e:	59 f0       	breq	.+22     	; 0x1346 <pin_set_bit+0x3e>
        set_pin(p);
    } else {
        clear_pin(p);
    }
}
    1330:	27 96       	adiw	r28, 0x07	; 7
    1332:	0f b6       	in	r0, 0x3f	; 63
    1334:	f8 94       	cli
    1336:	de bf       	out	0x3e, r29	; 62
    1338:	0f be       	out	0x3f, r0	; 63
    133a:	cd bf       	out	0x3d, r28	; 61
    133c:	df 91       	pop	r29
    133e:	cf 91       	pop	r28
    1340:	0f 91       	pop	r16
    _delay_ms(3);
}

void pin_set_bit(pin p, bool high) {
    if (high) {
        set_pin(p);
    1342:	0c 94 5b 0b 	jmp	0x16b6	; 0x16b6 <set_pin>
    } else {
        clear_pin(p);
    1346:	29 81       	ldd	r18, Y+1	; 0x01
    1348:	3a 81       	ldd	r19, Y+2	; 0x02
    134a:	4b 81       	ldd	r20, Y+3	; 0x03
    134c:	5c 81       	ldd	r21, Y+4	; 0x04
    134e:	6d 81       	ldd	r22, Y+5	; 0x05
    1350:	7e 81       	ldd	r23, Y+6	; 0x06
    1352:	8f 81       	ldd	r24, Y+7	; 0x07
    }
}
    1354:	27 96       	adiw	r28, 0x07	; 7
    1356:	0f b6       	in	r0, 0x3f	; 63
    1358:	f8 94       	cli
    135a:	de bf       	out	0x3e, r29	; 62
    135c:	0f be       	out	0x3f, r0	; 63
    135e:	cd bf       	out	0x3d, r28	; 61
    1360:	df 91       	pop	r29
    1362:	cf 91       	pop	r28
    1364:	0f 91       	pop	r16

void pin_set_bit(pin p, bool high) {
    if (high) {
        set_pin(p);
    } else {
        clear_pin(p);
    1366:	0c 94 82 0b 	jmp	0x1704	; 0x1704 <clear_pin>

0000136a <lcd_send_nibble8>:
    }
}

void lcd_send_nibble8(hd44780 *lcd, char nibble, bool lcd_register) {
    136a:	cf 92       	push	r12
    136c:	df 92       	push	r13
    136e:	ef 92       	push	r14
    1370:	ff 92       	push	r15
    1372:	0f 93       	push	r16
    1374:	1f 93       	push	r17
    1376:	cf 93       	push	r28
    1378:	df 93       	push	r29
    137a:	8c 01       	movw	r16, r24
    137c:	c4 2e       	mov	r12, r20
    // Put the nibble (or byte) on the port lines.
    //_SFR_BYTE(*lcd->db[0].port) = nibble;
    for (int i = 0; i < 8; i++) {
    137e:	c0 e0       	ldi	r28, 0x00	; 0
    1380:	d0 e0       	ldi	r29, 0x00	; 0
        bool high = (nibble >> i) & 0x01;
    1382:	e6 2e       	mov	r14, r22
    1384:	f1 2c       	mov	r15, r1
        if (high) {
            set_pin(lcd->db[i]);
        } else {
            clear_pin(lcd->db[i]);
    1386:	87 e0       	ldi	r24, 0x07	; 7
    1388:	d8 2e       	mov	r13, r24

void lcd_send_nibble8(hd44780 *lcd, char nibble, bool lcd_register) {
    // Put the nibble (or byte) on the port lines.
    //_SFR_BYTE(*lcd->db[0].port) = nibble;
    for (int i = 0; i < 8; i++) {
        bool high = (nibble >> i) & 0x01;
    138a:	c7 01       	movw	r24, r14
    138c:	0c 2e       	mov	r0, r28
    138e:	02 c0       	rjmp	.+4      	; 0x1394 <lcd_send_nibble8+0x2a>
    1390:	95 95       	asr	r25
    1392:	87 95       	ror	r24
    1394:	0a 94       	dec	r0
    1396:	e2 f7       	brpl	.-8      	; 0x1390 <lcd_send_nibble8+0x26>
        if (high) {
            set_pin(lcd->db[i]);
    1398:	dc 9e       	mul	r13, r28
    139a:	d0 01       	movw	r26, r0
    139c:	dd 9e       	mul	r13, r29
    139e:	b0 0d       	add	r27, r0
    13a0:	11 24       	eor	r1, r1
    13a2:	a0 0f       	add	r26, r16
    13a4:	b1 1f       	adc	r27, r17
    13a6:	fd 01       	movw	r30, r26
    13a8:	75 96       	adiw	r30, 0x15	; 21
    13aa:	55 96       	adiw	r26, 0x15	; 21
    13ac:	2c 91       	ld	r18, X
    13ae:	31 81       	ldd	r19, Z+1	; 0x01
    13b0:	42 81       	ldd	r20, Z+2	; 0x02
    13b2:	53 81       	ldd	r21, Z+3	; 0x03
    13b4:	64 81       	ldd	r22, Z+4	; 0x04
    13b6:	75 81       	ldd	r23, Z+5	; 0x05
void lcd_send_nibble8(hd44780 *lcd, char nibble, bool lcd_register) {
    // Put the nibble (or byte) on the port lines.
    //_SFR_BYTE(*lcd->db[0].port) = nibble;
    for (int i = 0; i < 8; i++) {
        bool high = (nibble >> i) & 0x01;
        if (high) {
    13b8:	80 ff       	sbrs	r24, 0
    13ba:	04 c0       	rjmp	.+8      	; 0x13c4 <lcd_send_nibble8+0x5a>
            set_pin(lcd->db[i]);
    13bc:	86 81       	ldd	r24, Z+6	; 0x06
    13be:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <set_pin>
    13c2:	03 c0       	rjmp	.+6      	; 0x13ca <lcd_send_nibble8+0x60>
        } else {
            clear_pin(lcd->db[i]);
    13c4:	86 81       	ldd	r24, Z+6	; 0x06
    13c6:	0e 94 82 0b 	call	0x1704	; 0x1704 <clear_pin>
}

void lcd_send_nibble8(hd44780 *lcd, char nibble, bool lcd_register) {
    // Put the nibble (or byte) on the port lines.
    //_SFR_BYTE(*lcd->db[0].port) = nibble;
    for (int i = 0; i < 8; i++) {
    13ca:	21 96       	adiw	r28, 0x01	; 1
    13cc:	c8 30       	cpi	r28, 0x08	; 8
    13ce:	d1 05       	cpc	r29, r1
    13d0:	e1 f6       	brne	.-72     	; 0x138a <lcd_send_nibble8+0x20>
        } else {
            clear_pin(lcd->db[i]);
        }
    }
    
    lcd_toggle_send_register(lcd, lcd_register);
    13d2:	6c 2d       	mov	r22, r12
    13d4:	c8 01       	movw	r24, r16
}
    13d6:	df 91       	pop	r29
    13d8:	cf 91       	pop	r28
    13da:	1f 91       	pop	r17
    13dc:	0f 91       	pop	r16
    13de:	ff 90       	pop	r15
    13e0:	ef 90       	pop	r14
    13e2:	df 90       	pop	r13
    13e4:	cf 90       	pop	r12
        } else {
            clear_pin(lcd->db[i]);
        }
    }
    
    lcd_toggle_send_register(lcd, lcd_register);
    13e6:	0c 94 56 09 	jmp	0x12ac	; 0x12ac <lcd_toggle_send_register>

000013ea <lcd_send_nibble4>:
}

void lcd_send_nibble4(hd44780* lcd, char nibble, bool lcd_register) {
    13ea:	cf 92       	push	r12
    13ec:	df 92       	push	r13
    13ee:	ef 92       	push	r14
    13f0:	ff 92       	push	r15
    13f2:	0f 93       	push	r16
    13f4:	1f 93       	push	r17
    13f6:	cf 93       	push	r28
    13f8:	df 93       	push	r29
    13fa:	8c 01       	movw	r16, r24
    13fc:	c4 2e       	mov	r12, r20
    13fe:	c4 e0       	ldi	r28, 0x04	; 4
    1400:	d0 e0       	ldi	r29, 0x00	; 0
    for (int i = 0; i < 4; i++) {
        bool high = (nibble >> i) & 0x01;
    1402:	e6 2e       	mov	r14, r22
    1404:	f1 2c       	mov	r15, r1
        if (high) {
            set_pin(lcd->db[i + 4]);
        } else {
            clear_pin(lcd->db[i + 4]);
    1406:	97 e0       	ldi	r25, 0x07	; 7
    1408:	d9 2e       	mov	r13, r25
    140a:	ce 01       	movw	r24, r28
    140c:	04 97       	sbiw	r24, 0x04	; 4
    lcd_toggle_send_register(lcd, lcd_register);
}

void lcd_send_nibble4(hd44780* lcd, char nibble, bool lcd_register) {
    for (int i = 0; i < 4; i++) {
        bool high = (nibble >> i) & 0x01;
    140e:	97 01       	movw	r18, r14
    1410:	02 c0       	rjmp	.+4      	; 0x1416 <lcd_send_nibble4+0x2c>
    1412:	35 95       	asr	r19
    1414:	27 95       	ror	r18
    1416:	8a 95       	dec	r24
    1418:	e2 f7       	brpl	.-8      	; 0x1412 <lcd_send_nibble4+0x28>
    141a:	c9 01       	movw	r24, r18
        if (high) {
            set_pin(lcd->db[i + 4]);
    141c:	dc 9e       	mul	r13, r28
    141e:	d0 01       	movw	r26, r0
    1420:	dd 9e       	mul	r13, r29
    1422:	b0 0d       	add	r27, r0
    1424:	11 24       	eor	r1, r1
    1426:	a0 0f       	add	r26, r16
    1428:	b1 1f       	adc	r27, r17
    142a:	fd 01       	movw	r30, r26
    142c:	75 96       	adiw	r30, 0x15	; 21
    142e:	55 96       	adiw	r26, 0x15	; 21
    1430:	2c 91       	ld	r18, X
    1432:	31 81       	ldd	r19, Z+1	; 0x01
    1434:	42 81       	ldd	r20, Z+2	; 0x02
    1436:	53 81       	ldd	r21, Z+3	; 0x03
    1438:	64 81       	ldd	r22, Z+4	; 0x04
    143a:	75 81       	ldd	r23, Z+5	; 0x05
}

void lcd_send_nibble4(hd44780* lcd, char nibble, bool lcd_register) {
    for (int i = 0; i < 4; i++) {
        bool high = (nibble >> i) & 0x01;
        if (high) {
    143c:	80 ff       	sbrs	r24, 0
    143e:	04 c0       	rjmp	.+8      	; 0x1448 <lcd_send_nibble4+0x5e>
            set_pin(lcd->db[i + 4]);
    1440:	86 81       	ldd	r24, Z+6	; 0x06
    1442:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <set_pin>
    1446:	03 c0       	rjmp	.+6      	; 0x144e <lcd_send_nibble4+0x64>
        } else {
            clear_pin(lcd->db[i + 4]);
    1448:	86 81       	ldd	r24, Z+6	; 0x06
    144a:	0e 94 82 0b 	call	0x1704	; 0x1704 <clear_pin>
    144e:	21 96       	adiw	r28, 0x01	; 1
    
    lcd_toggle_send_register(lcd, lcd_register);
}

void lcd_send_nibble4(hd44780* lcd, char nibble, bool lcd_register) {
    for (int i = 0; i < 4; i++) {
    1450:	c8 30       	cpi	r28, 0x08	; 8
    1452:	d1 05       	cpc	r29, r1
    1454:	d1 f6       	brne	.-76     	; 0x140a <lcd_send_nibble4+0x20>
        } else {
            clear_pin(lcd->db[i + 4]);
        }
    }

    lcd_toggle_send_register(lcd, lcd_register);
    1456:	6c 2d       	mov	r22, r12
    1458:	c8 01       	movw	r24, r16
}
    145a:	df 91       	pop	r29
    145c:	cf 91       	pop	r28
    145e:	1f 91       	pop	r17
    1460:	0f 91       	pop	r16
    1462:	ff 90       	pop	r15
    1464:	ef 90       	pop	r14
    1466:	df 90       	pop	r13
    1468:	cf 90       	pop	r12
        } else {
            clear_pin(lcd->db[i + 4]);
        }
    }

    lcd_toggle_send_register(lcd, lcd_register);
    146a:	0c 94 56 09 	jmp	0x12ac	; 0x12ac <lcd_toggle_send_register>

0000146e <lcd_send_byte>:
}

void lcd_send_byte(hd44780 *lcd, char byte, bool lcd_register) {
    146e:	0f 93       	push	r16
    1470:	1f 93       	push	r17
    1472:	cf 93       	push	r28
    1474:	df 93       	push	r29
    1476:	ec 01       	movw	r28, r24
    1478:	16 2f       	mov	r17, r22
    147a:	04 2f       	mov	r16, r20
    if (lcd->mode == LCD_4BITS) {
    147c:	fc 01       	movw	r30, r24
    147e:	e3 5b       	subi	r30, 0xB3	; 179
    1480:	ff 4f       	sbci	r31, 0xFF	; 255
    1482:	80 81       	ld	r24, Z
    1484:	81 11       	cpse	r24, r1
    1486:	0e c0       	rjmp	.+28     	; 0x14a4 <lcd_send_byte+0x36>
        lcd_send_nibble4(lcd, byte >> 4, lcd_register);
    1488:	62 95       	swap	r22
    148a:	6f 70       	andi	r22, 0x0F	; 15
    148c:	ce 01       	movw	r24, r28
    148e:	0e 94 f5 09 	call	0x13ea	; 0x13ea <lcd_send_nibble4>
        lcd_send_nibble4(lcd, byte, lcd_register);
    1492:	40 2f       	mov	r20, r16
    1494:	61 2f       	mov	r22, r17
    1496:	ce 01       	movw	r24, r28
    } else {
        lcd_send_nibble8(lcd, byte, lcd_register);
    }
}
    1498:	df 91       	pop	r29
    149a:	cf 91       	pop	r28
    149c:	1f 91       	pop	r17
    149e:	0f 91       	pop	r16
}

void lcd_send_byte(hd44780 *lcd, char byte, bool lcd_register) {
    if (lcd->mode == LCD_4BITS) {
        lcd_send_nibble4(lcd, byte >> 4, lcd_register);
        lcd_send_nibble4(lcd, byte, lcd_register);
    14a0:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <lcd_send_nibble4>
    } else {
        lcd_send_nibble8(lcd, byte, lcd_register);
    14a4:	ce 01       	movw	r24, r28
    }
}
    14a6:	df 91       	pop	r29
    14a8:	cf 91       	pop	r28
    14aa:	1f 91       	pop	r17
    14ac:	0f 91       	pop	r16
void lcd_send_byte(hd44780 *lcd, char byte, bool lcd_register) {
    if (lcd->mode == LCD_4BITS) {
        lcd_send_nibble4(lcd, byte >> 4, lcd_register);
        lcd_send_nibble4(lcd, byte, lcd_register);
    } else {
        lcd_send_nibble8(lcd, byte, lcd_register);
    14ae:	0c 94 b5 09 	jmp	0x136a	; 0x136a <lcd_send_nibble8>

000014b2 <lcd_send_data>:
    }
}

void lcd_send_data(hd44780 *lcd, char byte) {
    lcd_send_byte(lcd, byte, LCD_DATA_REGISTER);
    14b2:	41 e0       	ldi	r20, 0x01	; 1
    14b4:	0c 94 37 0a 	jmp	0x146e	; 0x146e <lcd_send_byte>

000014b8 <lcd_send_command>:
}

void lcd_send_command(hd44780* lcd, char byte) {
    lcd_send_byte(lcd, byte, LCD_COMMAND_REGISTER);
    14b8:	40 e0       	ldi	r20, 0x00	; 0
    14ba:	0c 94 37 0a 	jmp	0x146e	; 0x146e <lcd_send_byte>

000014be <lcd_init>:
}

void lcd_init(hd44780* lcd) {
    14be:	df 92       	push	r13
    14c0:	ef 92       	push	r14
    14c2:	ff 92       	push	r15
    14c4:	0f 93       	push	r16
    14c6:	1f 93       	push	r17
    14c8:	cf 93       	push	r28
    14ca:	df 93       	push	r29
    14cc:	ec 01       	movw	r28, r24
    // Set the pin outputs just in case that hasn't happend yet.
    output_pin(lcd->rs);
    14ce:	28 81       	ld	r18, Y
    14d0:	39 81       	ldd	r19, Y+1	; 0x01
    14d2:	4a 81       	ldd	r20, Y+2	; 0x02
    14d4:	5b 81       	ldd	r21, Y+3	; 0x03
    14d6:	6c 81       	ldd	r22, Y+4	; 0x04
    14d8:	7d 81       	ldd	r23, Y+5	; 0x05
    14da:	8e 81       	ldd	r24, Y+6	; 0x06
    14dc:	0e 94 cf 0b 	call	0x179e	; 0x179e <output_pin>
    output_pin(lcd->rw);
    14e0:	2f 81       	ldd	r18, Y+7	; 0x07
    14e2:	38 85       	ldd	r19, Y+8	; 0x08
    14e4:	49 85       	ldd	r20, Y+9	; 0x09
    14e6:	5a 85       	ldd	r21, Y+10	; 0x0a
    14e8:	6b 85       	ldd	r22, Y+11	; 0x0b
    14ea:	7c 85       	ldd	r23, Y+12	; 0x0c
    14ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    14ee:	0e 94 cf 0b 	call	0x179e	; 0x179e <output_pin>
    output_pin(lcd->e);
    14f2:	2e 85       	ldd	r18, Y+14	; 0x0e
    14f4:	3f 85       	ldd	r19, Y+15	; 0x0f
    14f6:	48 89       	ldd	r20, Y+16	; 0x10
    14f8:	59 89       	ldd	r21, Y+17	; 0x11
    14fa:	6a 89       	ldd	r22, Y+18	; 0x12
    14fc:	7b 89       	ldd	r23, Y+19	; 0x13
    14fe:	8c 89       	ldd	r24, Y+20	; 0x14
    1500:	0e 94 cf 0b 	call	0x179e	; 0x179e <output_pin>
    for (int i = 0; i < 8; i++) {
    1504:	00 e0       	ldi	r16, 0x00	; 0
    1506:	10 e0       	ldi	r17, 0x00	; 0
        if (lcd->mode == LCD_4BITS && i < 4) {
    1508:	7e 01       	movw	r14, r28
    150a:	2d e4       	ldi	r18, 0x4D	; 77
    150c:	e2 0e       	add	r14, r18
    150e:	f1 1c       	adc	r15, r1
            continue;
        }
        output_pin(lcd->db[i]);
    1510:	27 e0       	ldi	r18, 0x07	; 7
    1512:	d2 2e       	mov	r13, r18
    // Set the pin outputs just in case that hasn't happend yet.
    output_pin(lcd->rs);
    output_pin(lcd->rw);
    output_pin(lcd->e);
    for (int i = 0; i < 8; i++) {
        if (lcd->mode == LCD_4BITS && i < 4) {
    1514:	f7 01       	movw	r30, r14
    1516:	80 81       	ld	r24, Z
    1518:	81 11       	cpse	r24, r1
    151a:	03 c0       	rjmp	.+6      	; 0x1522 <lcd_init+0x64>
    151c:	04 30       	cpi	r16, 0x04	; 4
    151e:	11 05       	cpc	r17, r1
    1520:	9c f0       	brlt	.+38     	; 0x1548 <lcd_init+0x8a>
            continue;
        }
        output_pin(lcd->db[i]);
    1522:	d0 9e       	mul	r13, r16
    1524:	d0 01       	movw	r26, r0
    1526:	d1 9e       	mul	r13, r17
    1528:	b0 0d       	add	r27, r0
    152a:	11 24       	eor	r1, r1
    152c:	ac 0f       	add	r26, r28
    152e:	bd 1f       	adc	r27, r29
    1530:	fd 01       	movw	r30, r26
    1532:	75 96       	adiw	r30, 0x15	; 21
    1534:	55 96       	adiw	r26, 0x15	; 21
    1536:	2c 91       	ld	r18, X
    1538:	31 81       	ldd	r19, Z+1	; 0x01
    153a:	42 81       	ldd	r20, Z+2	; 0x02
    153c:	53 81       	ldd	r21, Z+3	; 0x03
    153e:	64 81       	ldd	r22, Z+4	; 0x04
    1540:	75 81       	ldd	r23, Z+5	; 0x05
    1542:	86 81       	ldd	r24, Z+6	; 0x06
    1544:	0e 94 cf 0b 	call	0x179e	; 0x179e <output_pin>
void lcd_init(hd44780* lcd) {
    // Set the pin outputs just in case that hasn't happend yet.
    output_pin(lcd->rs);
    output_pin(lcd->rw);
    output_pin(lcd->e);
    for (int i = 0; i < 8; i++) {
    1548:	0f 5f       	subi	r16, 0xFF	; 255
    154a:	1f 4f       	sbci	r17, 0xFF	; 255
    154c:	08 30       	cpi	r16, 0x08	; 8
    154e:	11 05       	cpc	r17, r1
    1550:	09 f7       	brne	.-62     	; 0x1514 <lcd_init+0x56>
    1552:	ff ef       	ldi	r31, 0xFF	; 255
    1554:	29 ef       	ldi	r18, 0xF9	; 249
    1556:	80 e0       	ldi	r24, 0x00	; 0
    1558:	f1 50       	subi	r31, 0x01	; 1
    155a:	20 40       	sbci	r18, 0x00	; 0
    155c:	80 40       	sbci	r24, 0x00	; 0
    155e:	e1 f7       	brne	.-8      	; 0x1558 <lcd_init+0x9a>
    1560:	00 c0       	rjmp	.+0      	; 0x1562 <lcd_init+0xa4>
    1562:	00 00       	nop
        output_pin(lcd->db[i]);
    }
    
    _delay_ms(20);				    // display reset takes 20ms
    
    uint8_t op = lcd_function_set_flags(LCD_8BITS, 0, 0);
    1564:	40 e0       	ldi	r20, 0x00	; 0
    1566:	60 e0       	ldi	r22, 0x00	; 0
    1568:	81 e0       	ldi	r24, 0x01	; 1
    156a:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <lcd_function_set_flags>
    156e:	18 2f       	mov	r17, r24
    lcd_send_nibble8(lcd, op, LCD_COMMAND_REGISTER);
    1570:	40 e0       	ldi	r20, 0x00	; 0
    1572:	68 2f       	mov	r22, r24
    1574:	ce 01       	movw	r24, r28
    1576:	0e 94 b5 09 	call	0x136a	; 0x136a <lcd_send_nibble8>
    157a:	ef e1       	ldi	r30, 0x1F	; 31
    157c:	fe e4       	ldi	r31, 0x4E	; 78
    157e:	31 97       	sbiw	r30, 0x01	; 1
    1580:	f1 f7       	brne	.-4      	; 0x157e <lcd_init+0xc0>
    1582:	00 c0       	rjmp	.+0      	; 0x1584 <lcd_init+0xc6>
    1584:	00 00       	nop
    
    _delay_ms(5);
    
    lcd_send_nibble8(lcd, op, LCD_COMMAND_REGISTER);
    1586:	40 e0       	ldi	r20, 0x00	; 0
    1588:	61 2f       	mov	r22, r17
    158a:	ce 01       	movw	r24, r28
    158c:	0e 94 b5 09 	call	0x136a	; 0x136a <lcd_send_nibble8>
    1590:	8f e9       	ldi	r24, 0x9F	; 159
    1592:	9f e0       	ldi	r25, 0x0F	; 15
    1594:	01 97       	sbiw	r24, 0x01	; 1
    1596:	f1 f7       	brne	.-4      	; 0x1594 <lcd_init+0xd6>
    1598:	00 c0       	rjmp	.+0      	; 0x159a <lcd_init+0xdc>
    159a:	00 00       	nop
    
    _delay_ms(1);

    lcd_send_nibble8(lcd, op, LCD_COMMAND_REGISTER);
    159c:	40 e0       	ldi	r20, 0x00	; 0
    159e:	61 2f       	mov	r22, r17
    15a0:	ce 01       	movw	r24, r28
    15a2:	0e 94 b5 09 	call	0x136a	; 0x136a <lcd_send_nibble8>
    15a6:	ef e9       	ldi	r30, 0x9F	; 159
    15a8:	ff e0       	ldi	r31, 0x0F	; 15
    15aa:	31 97       	sbiw	r30, 0x01	; 1
    15ac:	f1 f7       	brne	.-4      	; 0x15aa <lcd_init+0xec>
    15ae:	00 c0       	rjmp	.+0      	; 0x15b0 <lcd_init+0xf2>
    15b0:	00 00       	nop
    
    _delay_ms(1);
    
    // set interface to mode
    uint8_t funset = lcd_function_set_flags(lcd->mode, 0, 0);
    15b2:	40 e0       	ldi	r20, 0x00	; 0
    15b4:	60 e0       	ldi	r22, 0x00	; 0
    15b6:	f7 01       	movw	r30, r14
    15b8:	80 81       	ld	r24, Z
    15ba:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <lcd_function_set_flags>
    lcd_send_nibble8(lcd, funset, LCD_COMMAND_REGISTER);
    15be:	40 e0       	ldi	r20, 0x00	; 0
    15c0:	68 2f       	mov	r22, r24
    15c2:	ce 01       	movw	r24, r28
    15c4:	0e 94 b5 09 	call	0x136a	; 0x136a <lcd_send_nibble8>
    
    // Basic initialization is done and we can start talking in our target mode.
    // Set display lines and font
    funset = lcd_function_set_flags(lcd->mode, LCD_2LINES, LCD_5x8DOTS);
    15c8:	40 e0       	ldi	r20, 0x00	; 0
    15ca:	61 e0       	ldi	r22, 0x01	; 1
    15cc:	f7 01       	movw	r30, r14
    15ce:	80 81       	ld	r24, Z
    15d0:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <lcd_function_set_flags>
    lcd_send_command(lcd, funset);
    15d4:	68 2f       	mov	r22, r24
    15d6:	ce 01       	movw	r24, r28
    15d8:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <lcd_send_command>
    
    // Set display, cursor and cursor blinking
    uint8_t display = lcd_display_toggle_flags(LCD_DISPLAYON, LCD_CURSORON, LCD_CURSORBLINKON);
    15dc:	41 e0       	ldi	r20, 0x01	; 1
    15de:	61 e0       	ldi	r22, 0x01	; 1
    15e0:	81 e0       	ldi	r24, 0x01	; 1
    15e2:	0e 94 00 09 	call	0x1200	; 0x1200 <lcd_display_toggle_flags>
    lcd_send_command(lcd, display);
    15e6:	68 2f       	mov	r22, r24
    15e8:	ce 01       	movw	r24, r28
    15ea:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <lcd_send_command>
    
    // Clear it
    lcd_send_command(lcd, lcd_display_clear_flags());
    15ee:	61 e0       	ldi	r22, 0x01	; 1
    15f0:	ce 01       	movw	r24, r28
    15f2:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <lcd_send_command>
    
    // Set increment and shifting
    uint8_t entry = lcd_entry_mode_set_flags(LCD_ENTRYINC, LCD_ENTRYSHIFTOFF);
    15f6:	60 e0       	ldi	r22, 0x00	; 0
    15f8:	81 e0       	ldi	r24, 0x01	; 1
    15fa:	0e 94 26 09 	call	0x124c	; 0x124c <lcd_entry_mode_set_flags>
    lcd_send_command(lcd, entry);
    15fe:	68 2f       	mov	r22, r24
    1600:	ce 01       	movw	r24, r28
}
    1602:	df 91       	pop	r29
    1604:	cf 91       	pop	r28
    1606:	1f 91       	pop	r17
    1608:	0f 91       	pop	r16
    160a:	ff 90       	pop	r15
    160c:	ef 90       	pop	r14
    160e:	df 90       	pop	r13
    // Clear it
    lcd_send_command(lcd, lcd_display_clear_flags());
    
    // Set increment and shifting
    uint8_t entry = lcd_entry_mode_set_flags(LCD_ENTRYINC, LCD_ENTRYSHIFTOFF);
    lcd_send_command(lcd, entry);
    1610:	0c 94 5c 0a 	jmp	0x14b8	; 0x14b8 <lcd_send_command>

00001614 <lcd_write>:
}

static const uint8_t __line_address[] = {0, 0x40, 0x14, 0x54};

/** Writes the given string to the lcd. */
void lcd_write(hd44780 *lcd, const char *str) {
    1614:	ff 92       	push	r15
    1616:	0f 93       	push	r16
    1618:	1f 93       	push	r17
    161a:	cf 93       	push	r28
    161c:	df 93       	push	r29
    161e:	ec 01       	movw	r28, r24
    1620:	8b 01       	movw	r16, r22
    uint8_t line = 0;
    1622:	f1 2c       	mov	r15, r1
    while (*str) {
    1624:	f8 01       	movw	r30, r16
    1626:	61 91       	ld	r22, Z+
    1628:	8f 01       	movw	r16, r30
    162a:	66 23       	and	r22, r22
    162c:	91 f0       	breq	.+36     	; 0x1652 <lcd_write+0x3e>
        char c = *str++;
        if (c == '\n') {
    162e:	6a 30       	cpi	r22, 0x0A	; 10
    1630:	61 f4       	brne	.+24     	; 0x164a <lcd_write+0x36>
            line += 1;
    1632:	f3 94       	inc	r15
            uint8_t addr = __line_address[line % 4];
    1634:	ef 2d       	mov	r30, r15
    1636:	e3 70       	andi	r30, 0x03	; 3
    1638:	f0 e0       	ldi	r31, 0x00	; 0
    163a:	ef 5e       	subi	r30, 0xEF	; 239
    163c:	fe 4f       	sbci	r31, 0xFE	; 254
 Data is then written to or read from the MPU for DDRAM.
 However, when N is 0 (1-line display), AAAAAAA can be 00H to 4FH. When N is 1 (2-line display),
 AAAAAAA can be 00H to 27H for the first line, and 40H to 67H for the second line.
 */
uint8_t lcd_set_ddram_addr(uint8_t address) {
    uint8_t flags = 0x80 + address;
    163e:	60 81       	ld	r22, Z
    1640:	60 58       	subi	r22, 0x80	; 128
        char c = *str++;
        if (c == '\n') {
            line += 1;
            uint8_t addr = __line_address[line % 4];
            uint8_t flags = lcd_set_ddram_addr(addr);
            lcd_send_command(lcd, flags);
    1642:	ce 01       	movw	r24, r28
    1644:	0e 94 5c 0a 	call	0x14b8	; 0x14b8 <lcd_send_command>
            continue;
    1648:	ed cf       	rjmp	.-38     	; 0x1624 <lcd_write+0x10>
        }
        lcd_send_data(lcd, c);
    164a:	ce 01       	movw	r24, r28
    164c:	0e 94 59 0a 	call	0x14b2	; 0x14b2 <lcd_send_data>
    1650:	e9 cf       	rjmp	.-46     	; 0x1624 <lcd_write+0x10>
    }
}
    1652:	df 91       	pop	r29
    1654:	cf 91       	pop	r28
    1656:	1f 91       	pop	r17
    1658:	0f 91       	pop	r16
    165a:	ff 90       	pop	r15
    165c:	08 95       	ret

0000165e <lcd_xy>:

void lcd_xy(hd44780 *lcd, uint8_t x, uint8_t y) {
    uint8_t addr = lcd_set_ddram_addr(__line_address[y % 4] + x);
    165e:	60 58       	subi	r22, 0x80	; 128
    1660:	43 70       	andi	r20, 0x03	; 3
    1662:	e4 2f       	mov	r30, r20
    1664:	f0 e0       	ldi	r31, 0x00	; 0
    1666:	ef 5e       	subi	r30, 0xEF	; 239
    1668:	fe 4f       	sbci	r31, 0xFE	; 254
 Data is then written to or read from the MPU for DDRAM.
 However, when N is 0 (1-line display), AAAAAAA can be 00H to 4FH. When N is 1 (2-line display),
 AAAAAAA can be 00H to 27H for the first line, and 40H to 67H for the second line.
 */
uint8_t lcd_set_ddram_addr(uint8_t address) {
    uint8_t flags = 0x80 + address;
    166a:	20 81       	ld	r18, Z
    166c:	62 0f       	add	r22, r18
    }
}

void lcd_xy(hd44780 *lcd, uint8_t x, uint8_t y) {
    uint8_t addr = lcd_set_ddram_addr(__line_address[y % 4] + x);
    lcd_send_command(lcd, addr);
    166e:	0c 94 5c 0a 	jmp	0x14b8	; 0x14b8 <lcd_send_command>

00001672 <pin_make>:
//  Copyright (c) 2015 zyghost. All rights reserved.
//

#include "pin.h"

pin pin_make(volatile uint8_t *port, volatile uint8_t *ddr, volatile uint8_t *pinr, uint8_t bit) {
    1672:	cf 93       	push	r28
    1674:	df 93       	push	r29
    1676:	cd b7       	in	r28, 0x3d	; 61
    1678:	de b7       	in	r29, 0x3e	; 62
    167a:	27 97       	sbiw	r28, 0x07	; 7
    167c:	0f b6       	in	r0, 0x3f	; 63
    167e:	f8 94       	cli
    1680:	de bf       	out	0x3e, r29	; 62
    1682:	0f be       	out	0x3f, r0	; 63
    1684:	cd bf       	out	0x3d, r28	; 61
    1686:	e2 2f       	mov	r30, r18
    pin p;
    p.port = port;
    p.ddr = ddr;
    p.pinr = pinr;
    p.bit = bit;
    return p;
    1688:	89 83       	std	Y+1, r24	; 0x01
    168a:	9a 83       	std	Y+2, r25	; 0x02
    168c:	6b 83       	std	Y+3, r22	; 0x03
    168e:	7c 83       	std	Y+4, r23	; 0x04
    1690:	4d 83       	std	Y+5, r20	; 0x05
    1692:	5e 83       	std	Y+6, r21	; 0x06
    1694:	9c 01       	movw	r18, r24
    1696:	96 2f       	mov	r25, r22
    1698:	57 2f       	mov	r21, r23
    169a:	64 2f       	mov	r22, r20
    169c:	7e 81       	ldd	r23, Y+6	; 0x06
}
    169e:	49 2f       	mov	r20, r25
    16a0:	8e 2f       	mov	r24, r30
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	27 96       	adiw	r28, 0x07	; 7
    16a6:	0f b6       	in	r0, 0x3f	; 63
    16a8:	f8 94       	cli
    16aa:	de bf       	out	0x3e, r29	; 62
    16ac:	0f be       	out	0x3f, r0	; 63
    16ae:	cd bf       	out	0x3d, r28	; 61
    16b0:	df 91       	pop	r29
    16b2:	cf 91       	pop	r28
    16b4:	08 95       	ret

000016b6 <set_pin>:

void set_pin(pin p) {
    16b6:	cf 93       	push	r28
    16b8:	df 93       	push	r29
    16ba:	cd b7       	in	r28, 0x3d	; 61
    16bc:	de b7       	in	r29, 0x3e	; 62
    16be:	27 97       	sbiw	r28, 0x07	; 7
    16c0:	0f b6       	in	r0, 0x3f	; 63
    16c2:	f8 94       	cli
    16c4:	de bf       	out	0x3e, r29	; 62
    16c6:	0f be       	out	0x3f, r0	; 63
    16c8:	cd bf       	out	0x3d, r28	; 61
    16ca:	29 83       	std	Y+1, r18	; 0x01
    16cc:	3a 83       	std	Y+2, r19	; 0x02
    16ce:	4b 83       	std	Y+3, r20	; 0x03
    16d0:	5c 83       	std	Y+4, r21	; 0x04
    16d2:	6d 83       	std	Y+5, r22	; 0x05
    16d4:	7e 83       	std	Y+6, r23	; 0x06
    16d6:	8f 83       	std	Y+7, r24	; 0x07
    set_bit(*p.port, p.bit);
    16d8:	e9 81       	ldd	r30, Y+1	; 0x01
    16da:	fa 81       	ldd	r31, Y+2	; 0x02
    16dc:	20 81       	ld	r18, Z
    16de:	81 e0       	ldi	r24, 0x01	; 1
    16e0:	90 e0       	ldi	r25, 0x00	; 0
    16e2:	0f 80       	ldd	r0, Y+7	; 0x07
    16e4:	02 c0       	rjmp	.+4      	; 0x16ea <set_pin+0x34>
    16e6:	88 0f       	add	r24, r24
    16e8:	99 1f       	adc	r25, r25
    16ea:	0a 94       	dec	r0
    16ec:	e2 f7       	brpl	.-8      	; 0x16e6 <set_pin+0x30>
    16ee:	28 2b       	or	r18, r24
    16f0:	20 83       	st	Z, r18
}
    16f2:	27 96       	adiw	r28, 0x07	; 7
    16f4:	0f b6       	in	r0, 0x3f	; 63
    16f6:	f8 94       	cli
    16f8:	de bf       	out	0x3e, r29	; 62
    16fa:	0f be       	out	0x3f, r0	; 63
    16fc:	cd bf       	out	0x3d, r28	; 61
    16fe:	df 91       	pop	r29
    1700:	cf 91       	pop	r28
    1702:	08 95       	ret

00001704 <clear_pin>:

void clear_pin(pin p) {
    1704:	cf 93       	push	r28
    1706:	df 93       	push	r29
    1708:	cd b7       	in	r28, 0x3d	; 61
    170a:	de b7       	in	r29, 0x3e	; 62
    170c:	27 97       	sbiw	r28, 0x07	; 7
    170e:	0f b6       	in	r0, 0x3f	; 63
    1710:	f8 94       	cli
    1712:	de bf       	out	0x3e, r29	; 62
    1714:	0f be       	out	0x3f, r0	; 63
    1716:	cd bf       	out	0x3d, r28	; 61
    1718:	29 83       	std	Y+1, r18	; 0x01
    171a:	3a 83       	std	Y+2, r19	; 0x02
    171c:	4b 83       	std	Y+3, r20	; 0x03
    171e:	5c 83       	std	Y+4, r21	; 0x04
    1720:	6d 83       	std	Y+5, r22	; 0x05
    1722:	7e 83       	std	Y+6, r23	; 0x06
    1724:	8f 83       	std	Y+7, r24	; 0x07
    clear_bit(*p.port, p.bit);
    1726:	e9 81       	ldd	r30, Y+1	; 0x01
    1728:	fa 81       	ldd	r31, Y+2	; 0x02
    172a:	20 81       	ld	r18, Z
    172c:	81 e0       	ldi	r24, 0x01	; 1
    172e:	90 e0       	ldi	r25, 0x00	; 0
    1730:	0f 80       	ldd	r0, Y+7	; 0x07
    1732:	02 c0       	rjmp	.+4      	; 0x1738 <clear_pin+0x34>
    1734:	88 0f       	add	r24, r24
    1736:	99 1f       	adc	r25, r25
    1738:	0a 94       	dec	r0
    173a:	e2 f7       	brpl	.-8      	; 0x1734 <clear_pin+0x30>
    173c:	80 95       	com	r24
    173e:	82 23       	and	r24, r18
    1740:	80 83       	st	Z, r24
}
    1742:	27 96       	adiw	r28, 0x07	; 7
    1744:	0f b6       	in	r0, 0x3f	; 63
    1746:	f8 94       	cli
    1748:	de bf       	out	0x3e, r29	; 62
    174a:	0f be       	out	0x3f, r0	; 63
    174c:	cd bf       	out	0x3d, r28	; 61
    174e:	df 91       	pop	r29
    1750:	cf 91       	pop	r28
    1752:	08 95       	ret

00001754 <read_pin>:

bool read_pin(pin p) {
    1754:	cf 93       	push	r28
    1756:	df 93       	push	r29
    1758:	cd b7       	in	r28, 0x3d	; 61
    175a:	de b7       	in	r29, 0x3e	; 62
    175c:	27 97       	sbiw	r28, 0x07	; 7
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	de bf       	out	0x3e, r29	; 62
    1764:	0f be       	out	0x3f, r0	; 63
    1766:	cd bf       	out	0x3d, r28	; 61
    1768:	29 83       	std	Y+1, r18	; 0x01
    176a:	3a 83       	std	Y+2, r19	; 0x02
    176c:	4b 83       	std	Y+3, r20	; 0x03
    176e:	5c 83       	std	Y+4, r21	; 0x04
    1770:	6d 83       	std	Y+5, r22	; 0x05
    1772:	7e 83       	std	Y+6, r23	; 0x06
    1774:	8f 83       	std	Y+7, r24	; 0x07
    return read_bit(*p.pinr, p.bit) ? 1 : 0;
    1776:	ed 81       	ldd	r30, Y+5	; 0x05
    1778:	fe 81       	ldd	r31, Y+6	; 0x06
    177a:	80 81       	ld	r24, Z
    177c:	90 e0       	ldi	r25, 0x00	; 0
    177e:	0f 80       	ldd	r0, Y+7	; 0x07
    1780:	02 c0       	rjmp	.+4      	; 0x1786 <read_pin+0x32>
    1782:	95 95       	asr	r25
    1784:	87 95       	ror	r24
    1786:	0a 94       	dec	r0
    1788:	e2 f7       	brpl	.-8      	; 0x1782 <read_pin+0x2e>
}
    178a:	81 70       	andi	r24, 0x01	; 1
    178c:	27 96       	adiw	r28, 0x07	; 7
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	de bf       	out	0x3e, r29	; 62
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	cd bf       	out	0x3d, r28	; 61
    1798:	df 91       	pop	r29
    179a:	cf 91       	pop	r28
    179c:	08 95       	ret

0000179e <output_pin>:

void output_pin(pin p) {
    179e:	cf 93       	push	r28
    17a0:	df 93       	push	r29
    17a2:	cd b7       	in	r28, 0x3d	; 61
    17a4:	de b7       	in	r29, 0x3e	; 62
    17a6:	27 97       	sbiw	r28, 0x07	; 7
    17a8:	0f b6       	in	r0, 0x3f	; 63
    17aa:	f8 94       	cli
    17ac:	de bf       	out	0x3e, r29	; 62
    17ae:	0f be       	out	0x3f, r0	; 63
    17b0:	cd bf       	out	0x3d, r28	; 61
    17b2:	29 83       	std	Y+1, r18	; 0x01
    17b4:	3a 83       	std	Y+2, r19	; 0x02
    17b6:	4b 83       	std	Y+3, r20	; 0x03
    17b8:	5c 83       	std	Y+4, r21	; 0x04
    17ba:	6d 83       	std	Y+5, r22	; 0x05
    17bc:	7e 83       	std	Y+6, r23	; 0x06
    17be:	8f 83       	std	Y+7, r24	; 0x07
    set_bit(*p.ddr, p.bit);
    17c0:	eb 81       	ldd	r30, Y+3	; 0x03
    17c2:	fc 81       	ldd	r31, Y+4	; 0x04
    17c4:	20 81       	ld	r18, Z
    17c6:	81 e0       	ldi	r24, 0x01	; 1
    17c8:	90 e0       	ldi	r25, 0x00	; 0
    17ca:	0f 80       	ldd	r0, Y+7	; 0x07
    17cc:	02 c0       	rjmp	.+4      	; 0x17d2 <output_pin+0x34>
    17ce:	88 0f       	add	r24, r24
    17d0:	99 1f       	adc	r25, r25
    17d2:	0a 94       	dec	r0
    17d4:	e2 f7       	brpl	.-8      	; 0x17ce <output_pin+0x30>
    17d6:	28 2b       	or	r18, r24
    17d8:	20 83       	st	Z, r18
}
    17da:	27 96       	adiw	r28, 0x07	; 7
    17dc:	0f b6       	in	r0, 0x3f	; 63
    17de:	f8 94       	cli
    17e0:	de bf       	out	0x3e, r29	; 62
    17e2:	0f be       	out	0x3f, r0	; 63
    17e4:	cd bf       	out	0x3d, r28	; 61
    17e6:	df 91       	pop	r29
    17e8:	cf 91       	pop	r28
    17ea:	08 95       	ret

000017ec <input_pin>:

void input_pin(pin p) {
    17ec:	cf 93       	push	r28
    17ee:	df 93       	push	r29
    17f0:	cd b7       	in	r28, 0x3d	; 61
    17f2:	de b7       	in	r29, 0x3e	; 62
    17f4:	27 97       	sbiw	r28, 0x07	; 7
    17f6:	0f b6       	in	r0, 0x3f	; 63
    17f8:	f8 94       	cli
    17fa:	de bf       	out	0x3e, r29	; 62
    17fc:	0f be       	out	0x3f, r0	; 63
    17fe:	cd bf       	out	0x3d, r28	; 61
    1800:	29 83       	std	Y+1, r18	; 0x01
    1802:	3a 83       	std	Y+2, r19	; 0x02
    1804:	4b 83       	std	Y+3, r20	; 0x03
    1806:	5c 83       	std	Y+4, r21	; 0x04
    1808:	6d 83       	std	Y+5, r22	; 0x05
    180a:	7e 83       	std	Y+6, r23	; 0x06
    180c:	8f 83       	std	Y+7, r24	; 0x07
    clear_bit(*p.ddr, p.bit);
    180e:	eb 81       	ldd	r30, Y+3	; 0x03
    1810:	fc 81       	ldd	r31, Y+4	; 0x04
    1812:	20 81       	ld	r18, Z
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	90 e0       	ldi	r25, 0x00	; 0
    1818:	0f 80       	ldd	r0, Y+7	; 0x07
    181a:	02 c0       	rjmp	.+4      	; 0x1820 <input_pin+0x34>
    181c:	88 0f       	add	r24, r24
    181e:	99 1f       	adc	r25, r25
    1820:	0a 94       	dec	r0
    1822:	e2 f7       	brpl	.-8      	; 0x181c <input_pin+0x30>
    1824:	80 95       	com	r24
    1826:	82 23       	and	r24, r18
    1828:	80 83       	st	Z, r24
    182a:	27 96       	adiw	r28, 0x07	; 7
    182c:	0f b6       	in	r0, 0x3f	; 63
    182e:	f8 94       	cli
    1830:	de bf       	out	0x3e, r29	; 62
    1832:	0f be       	out	0x3f, r0	; 63
    1834:	cd bf       	out	0x3d, r28	; 61
    1836:	df 91       	pop	r29
    1838:	cf 91       	pop	r28
    183a:	08 95       	ret

0000183c <usb_wait_in_ready>:


// Misc functions to wait for ready and send/receive packets
static inline void usb_wait_in_ready(void)
{
	while (!(UEINTX & (1<<TXINI))) ;
    183c:	80 91 e8 00 	lds	r24, 0x00E8
    1840:	80 ff       	sbrs	r24, 0
    1842:	fc cf       	rjmp	.-8      	; 0x183c <usb_wait_in_ready>
}
    1844:	08 95       	ret

00001846 <usb_init>:


// initialize USB
void usb_init(void)
{
	HW_CONFIG();
    1846:	81 e8       	ldi	r24, 0x81	; 129
    1848:	80 93 d7 00 	sts	0x00D7, r24
	USB_FREEZE();				// enable USB
    184c:	80 ea       	ldi	r24, 0xA0	; 160
    184e:	80 93 d8 00 	sts	0x00D8, r24
	PLL_CONFIG();				// config PLL
    1852:	86 e1       	ldi	r24, 0x16	; 22
    1854:	89 bd       	out	0x29, r24	; 41
        while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
    1856:	09 b4       	in	r0, 0x29	; 41
    1858:	00 fe       	sbrs	r0, 0
    185a:	fd cf       	rjmp	.-6      	; 0x1856 <usb_init+0x10>
        USB_CONFIG();				// start USB clock
    185c:	80 e9       	ldi	r24, 0x90	; 144
    185e:	80 93 d8 00 	sts	0x00D8, r24
        UDCON = 0;				// enable attach resistor
    1862:	10 92 e0 00 	sts	0x00E0, r1
	usb_configuration = 0;
    1866:	10 92 88 01 	sts	0x0188, r1
        UDIEN = (1<<EORSTE)|(1<<SOFE);
    186a:	8c e0       	ldi	r24, 0x0C	; 12
    186c:	80 93 e2 00 	sts	0x00E2, r24
	sei();
    1870:	78 94       	sei
    1872:	08 95       	ret

00001874 <usb_configured>:

// return 0 if the USB is not configured, or the configuration
// number selected by the HOST
uint8_t usb_configured(void)
{
	return usb_configuration;
    1874:	80 91 88 01 	lds	r24, 0x0188
}
    1878:	08 95       	ret

0000187a <usb_debug_putchar>:
{
	static uint8_t previous_timeout=0;
	uint8_t timeout, intr_state;

	// if we're not online (enumerated and configured), error
	if (!usb_configuration) return -1;
    187a:	90 91 88 01 	lds	r25, 0x0188
    187e:	99 23       	and	r25, r25
    1880:	71 f0       	breq	.+28     	; 0x189e <usb_debug_putchar+0x24>
	// interrupts are disabled so these functions can be
	// used from the main program or interrupt context,
	// even both in the same program!
	intr_state = SREG;
    1882:	9f b7       	in	r25, 0x3f	; 63
	cli();
    1884:	f8 94       	cli
	UENUM = DEBUG_TX_ENDPOINT;
    1886:	23 e0       	ldi	r18, 0x03	; 3
    1888:	20 93 e9 00 	sts	0x00E9, r18
	// if we gave up due to timeout before, don't wait again
	if (previous_timeout) {
    188c:	20 91 86 01 	lds	r18, 0x0186
    1890:	22 23       	and	r18, r18
    1892:	49 f0       	breq	.+18     	; 0x18a6 <usb_debug_putchar+0x2c>
		if (!(UEINTX & (1<<RWAL))) {
    1894:	20 91 e8 00 	lds	r18, 0x00E8
    1898:	25 fd       	sbrc	r18, 5
    189a:	03 c0       	rjmp	.+6      	; 0x18a2 <usb_debug_putchar+0x28>
			SREG = intr_state;
    189c:	9f bf       	out	0x3f, r25	; 63
			return -1;
    189e:	8f ef       	ldi	r24, 0xFF	; 255
    18a0:	08 95       	ret
		}
		previous_timeout = 0;
    18a2:	10 92 86 01 	sts	0x0186, r1
	}
	// wait for the FIFO to be ready to accept data
	timeout = UDFNUML + 4;
    18a6:	20 91 e4 00 	lds	r18, 0x00E4
    18aa:	2c 5f       	subi	r18, 0xFC	; 252
		// has the USB gone offline?
		if (!usb_configuration) return -1;
		// get ready to try checking again
		intr_state = SREG;
		cli();
		UENUM = DEBUG_TX_ENDPOINT;
    18ac:	33 e0       	ldi	r19, 0x03	; 3
	}
	// wait for the FIFO to be ready to accept data
	timeout = UDFNUML + 4;
	while (1) {
		// are we ready to transmit?
		if (UEINTX & (1<<RWAL)) break;
    18ae:	40 91 e8 00 	lds	r20, 0x00E8
    18b2:	45 fd       	sbrc	r20, 5
    18b4:	12 c0       	rjmp	.+36     	; 0x18da <usb_debug_putchar+0x60>
		SREG = intr_state;
    18b6:	9f bf       	out	0x3f, r25	; 63
		// have we waited too long?
		if (UDFNUML == timeout) {
    18b8:	90 91 e4 00 	lds	r25, 0x00E4
    18bc:	92 13       	cpse	r25, r18
    18be:	04 c0       	rjmp	.+8      	; 0x18c8 <usb_debug_putchar+0x4e>
			previous_timeout = 1;
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	80 93 86 01 	sts	0x0186, r24
    18c6:	eb cf       	rjmp	.-42     	; 0x189e <usb_debug_putchar+0x24>
			return -1;
		}
		// has the USB gone offline?
		if (!usb_configuration) return -1;
    18c8:	90 91 88 01 	lds	r25, 0x0188
    18cc:	99 23       	and	r25, r25
    18ce:	39 f3       	breq	.-50     	; 0x189e <usb_debug_putchar+0x24>
		// get ready to try checking again
		intr_state = SREG;
    18d0:	9f b7       	in	r25, 0x3f	; 63
		cli();
    18d2:	f8 94       	cli
		UENUM = DEBUG_TX_ENDPOINT;
    18d4:	30 93 e9 00 	sts	0x00E9, r19
	}
    18d8:	ea cf       	rjmp	.-44     	; 0x18ae <usb_debug_putchar+0x34>
	// actually write the byte into the FIFO
	UEDATX = c;
    18da:	80 93 f1 00 	sts	0x00F1, r24
	// if this completed a packet, transmit it now!
	if (!(UEINTX & (1<<RWAL))) {
    18de:	80 91 e8 00 	lds	r24, 0x00E8
    18e2:	85 fd       	sbrc	r24, 5
    18e4:	06 c0       	rjmp	.+12     	; 0x18f2 <usb_debug_putchar+0x78>
		UEINTX = 0x3A;
    18e6:	8a e3       	ldi	r24, 0x3A	; 58
    18e8:	80 93 e8 00 	sts	0x00E8, r24
		debug_flush_timer = 0;
    18ec:	10 92 87 01 	sts	0x0187, r1
    18f0:	03 c0       	rjmp	.+6      	; 0x18f8 <usb_debug_putchar+0x7e>
	} else {
		debug_flush_timer = 2;
    18f2:	82 e0       	ldi	r24, 0x02	; 2
    18f4:	80 93 87 01 	sts	0x0187, r24
	}
	SREG = intr_state;
    18f8:	9f bf       	out	0x3f, r25	; 63
	return 0;
    18fa:	80 e0       	ldi	r24, 0x00	; 0
}
    18fc:	08 95       	ret

000018fe <usb_debug_putstr>:

int8_t usb_debug_putstr(char* str) {
    18fe:	1f 93       	push	r17
    1900:	cf 93       	push	r28
    1902:	df 93       	push	r29
    1904:	ec 01       	movw	r28, r24
    for (uint8_t i = 0; str[i] != '\0'; i++) {
    1906:	10 e0       	ldi	r17, 0x00	; 0
    1908:	fe 01       	movw	r30, r28
    190a:	e1 0f       	add	r30, r17
    190c:	f1 1d       	adc	r31, r1
    190e:	80 81       	ld	r24, Z
    1910:	88 23       	and	r24, r24
    1912:	39 f0       	breq	.+14     	; 0x1922 <usb_debug_putstr+0x24>
        if (usb_debug_putchar(str[i]) < 0) {
    1914:	0e 94 3d 0c 	call	0x187a	; 0x187a <usb_debug_putchar>
    1918:	87 fd       	sbrc	r24, 7
    191a:	02 c0       	rjmp	.+4      	; 0x1920 <usb_debug_putstr+0x22>
	SREG = intr_state;
	return 0;
}

int8_t usb_debug_putstr(char* str) {
    for (uint8_t i = 0; str[i] != '\0'; i++) {
    191c:	1f 5f       	subi	r17, 0xFF	; 255
    191e:	f4 cf       	rjmp	.-24     	; 0x1908 <usb_debug_putstr+0xa>
        if (usb_debug_putchar(str[i]) < 0) {
            return -1;
    1920:	8f ef       	ldi	r24, 0xFF	; 255
        }
    }
    return 0;
}
    1922:	df 91       	pop	r29
    1924:	cf 91       	pop	r28
    1926:	1f 91       	pop	r17
    1928:	08 95       	ret

0000192a <usb_debug_flush_output>:
// immediately transmit any buffered output.
void usb_debug_flush_output(void)
{
	uint8_t intr_state;

	intr_state = SREG;
    192a:	8f b7       	in	r24, 0x3f	; 63
	cli();
    192c:	f8 94       	cli
	if (debug_flush_timer) {
    192e:	90 91 87 01 	lds	r25, 0x0187
    1932:	99 23       	and	r25, r25
    1934:	79 f0       	breq	.+30     	; 0x1954 <usb_debug_flush_output+0x2a>
		UENUM = DEBUG_TX_ENDPOINT;
    1936:	93 e0       	ldi	r25, 0x03	; 3
    1938:	90 93 e9 00 	sts	0x00E9, r25
		while ((UEINTX & (1<<RWAL))) {
    193c:	90 91 e8 00 	lds	r25, 0x00E8
    1940:	95 ff       	sbrs	r25, 5
    1942:	03 c0       	rjmp	.+6      	; 0x194a <usb_debug_flush_output+0x20>
			UEDATX = 0;
    1944:	10 92 f1 00 	sts	0x00F1, r1
    1948:	f9 cf       	rjmp	.-14     	; 0x193c <usb_debug_flush_output+0x12>
		}
		UEINTX = 0x3A;
    194a:	9a e3       	ldi	r25, 0x3A	; 58
    194c:	90 93 e8 00 	sts	0x00E8, r25
		debug_flush_timer = 0;
    1950:	10 92 87 01 	sts	0x0187, r1
	}
	SREG = intr_state;
    1954:	8f bf       	out	0x3f, r24	; 63
    1956:	08 95       	ret

00001958 <__vector_10>:

// USB Device Interrupt - handle all device-level events
// the transmit buffer flushing is triggered by the start of frame
//
ISR(USB_GEN_vect)
{
    1958:	1f 92       	push	r1
    195a:	0f 92       	push	r0
    195c:	0f b6       	in	r0, 0x3f	; 63
    195e:	0f 92       	push	r0
    1960:	11 24       	eor	r1, r1
    1962:	8f 93       	push	r24
    1964:	9f 93       	push	r25
	uint8_t intbits, t;

        intbits = UDINT;
    1966:	80 91 e1 00 	lds	r24, 0x00E1
        UDINT = 0;
    196a:	10 92 e1 00 	sts	0x00E1, r1
        if (intbits & (1<<EORSTI)) {
    196e:	83 ff       	sbrs	r24, 3
    1970:	0f c0       	rjmp	.+30     	; 0x1990 <__vector_10+0x38>
		UENUM = 0;
    1972:	10 92 e9 00 	sts	0x00E9, r1
		UECONX = 1;
    1976:	91 e0       	ldi	r25, 0x01	; 1
    1978:	90 93 eb 00 	sts	0x00EB, r25
		UECFG0X = EP_TYPE_CONTROL;
    197c:	10 92 ec 00 	sts	0x00EC, r1
		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
    1980:	92 e2       	ldi	r25, 0x22	; 34
    1982:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX = (1<<RXSTPE);
    1986:	98 e0       	ldi	r25, 0x08	; 8
    1988:	90 93 f0 00 	sts	0x00F0, r25
		usb_configuration = 0;
    198c:	10 92 88 01 	sts	0x0188, r1
        }
	if (intbits & (1<<SOFI)) {
    1990:	82 ff       	sbrs	r24, 2
    1992:	1a c0       	rjmp	.+52     	; 0x19c8 <__vector_10+0x70>
		if (usb_configuration) {
    1994:	80 91 88 01 	lds	r24, 0x0188
    1998:	88 23       	and	r24, r24
    199a:	b1 f0       	breq	.+44     	; 0x19c8 <__vector_10+0x70>
			t = debug_flush_timer;
    199c:	80 91 87 01 	lds	r24, 0x0187
			if (t) {
    19a0:	88 23       	and	r24, r24
    19a2:	91 f0       	breq	.+36     	; 0x19c8 <__vector_10+0x70>
				debug_flush_timer = -- t;
    19a4:	81 50       	subi	r24, 0x01	; 1
    19a6:	80 93 87 01 	sts	0x0187, r24
				if (!t) {
    19aa:	81 11       	cpse	r24, r1
    19ac:	0d c0       	rjmp	.+26     	; 0x19c8 <__vector_10+0x70>
					UENUM = DEBUG_TX_ENDPOINT;
    19ae:	83 e0       	ldi	r24, 0x03	; 3
    19b0:	80 93 e9 00 	sts	0x00E9, r24
					while ((UEINTX & (1<<RWAL))) {
    19b4:	80 91 e8 00 	lds	r24, 0x00E8
    19b8:	85 ff       	sbrs	r24, 5
    19ba:	03 c0       	rjmp	.+6      	; 0x19c2 <__vector_10+0x6a>
						UEDATX = 0;
    19bc:	10 92 f1 00 	sts	0x00F1, r1
    19c0:	f9 cf       	rjmp	.-14     	; 0x19b4 <__vector_10+0x5c>
					}
					UEINTX = 0x3A;
    19c2:	8a e3       	ldi	r24, 0x3A	; 58
    19c4:	80 93 e8 00 	sts	0x00E8, r24
				}
			}
		}
	}
}
    19c8:	9f 91       	pop	r25
    19ca:	8f 91       	pop	r24
    19cc:	0f 90       	pop	r0
    19ce:	0f be       	out	0x3f, r0	; 63
    19d0:	0f 90       	pop	r0
    19d2:	1f 90       	pop	r1
    19d4:	18 95       	reti

000019d6 <__vector_11>:
// USB Endpoint Interrupt - endpoint 0 is handled here.  The
// other endpoints are manipulated by the user-callable
// functions, and the start-of-frame interrupt.
//
ISR(USB_COM_vect)
{
    19d6:	1f 92       	push	r1
    19d8:	0f 92       	push	r0
    19da:	0f b6       	in	r0, 0x3f	; 63
    19dc:	0f 92       	push	r0
    19de:	11 24       	eor	r1, r1
    19e0:	0b b6       	in	r0, 0x3b	; 59
    19e2:	0f 92       	push	r0
    19e4:	ef 92       	push	r14
    19e6:	ff 92       	push	r15
    19e8:	0f 93       	push	r16
    19ea:	1f 93       	push	r17
    19ec:	2f 93       	push	r18
    19ee:	3f 93       	push	r19
    19f0:	4f 93       	push	r20
    19f2:	5f 93       	push	r21
    19f4:	6f 93       	push	r22
    19f6:	7f 93       	push	r23
    19f8:	8f 93       	push	r24
    19fa:	9f 93       	push	r25
    19fc:	af 93       	push	r26
    19fe:	bf 93       	push	r27
    1a00:	ef 93       	push	r30
    1a02:	ff 93       	push	r31
    1a04:	cf 93       	push	r28
    1a06:	df 93       	push	r29
    1a08:	1f 92       	push	r1
    1a0a:	cd b7       	in	r28, 0x3d	; 61
    1a0c:	de b7       	in	r29, 0x3e	; 62
	uint16_t wLength;
	uint16_t desc_val;
	const uint8_t *desc_addr;
	uint8_t	desc_length;

        UENUM = 0;
    1a0e:	10 92 e9 00 	sts	0x00E9, r1
        intbits = UEINTX;
    1a12:	80 91 e8 00 	lds	r24, 0x00E8
        if (intbits & (1<<RXSTPI)) {
    1a16:	83 ff       	sbrs	r24, 3
    1a18:	02 c1       	rjmp	.+516    	; 0x1c1e <__vector_11+0x248>
                bmRequestType = UEDATX;
    1a1a:	90 91 f1 00 	lds	r25, 0x00F1
                bRequest = UEDATX;
    1a1e:	80 91 f1 00 	lds	r24, 0x00F1
                wValue = UEDATX;
    1a22:	00 91 f1 00 	lds	r16, 0x00F1
                wValue |= (UEDATX << 8);
    1a26:	20 91 f1 00 	lds	r18, 0x00F1
    1a2a:	10 e0       	ldi	r17, 0x00	; 0
    1a2c:	12 2b       	or	r17, r18
                wIndex = UEDATX;
    1a2e:	30 91 f1 00 	lds	r19, 0x00F1
                wIndex |= (UEDATX << 8);
    1a32:	20 91 f1 00 	lds	r18, 0x00F1
    1a36:	e3 2e       	mov	r14, r19
    1a38:	f1 2c       	mov	r15, r1
    1a3a:	f2 2a       	or	r15, r18
                wLength = UEDATX;
    1a3c:	20 91 f1 00 	lds	r18, 0x00F1
                wLength |= (UEDATX << 8);
    1a40:	40 91 f1 00 	lds	r20, 0x00F1
    1a44:	30 e0       	ldi	r19, 0x00	; 0
    1a46:	34 2b       	or	r19, r20
                UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
    1a48:	42 ef       	ldi	r20, 0xF2	; 242
    1a4a:	40 93 e8 00 	sts	0x00E8, r20
                if (bRequest == GET_DESCRIPTOR) {
    1a4e:	86 30       	cpi	r24, 0x06	; 6
    1a50:	09 f0       	breq	.+2      	; 0x1a54 <__vector_11+0x7e>
    1a52:	44 c0       	rjmp	.+136    	; 0x1adc <__vector_11+0x106>
    1a54:	67 e0       	ldi	r22, 0x07	; 7
    1a56:	88 e9       	ldi	r24, 0x98	; 152
    1a58:	90 e0       	ldi	r25, 0x00	; 0
			for (i=0; ; i++) {
				if (i >= NUM_DESC_LIST) {
					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
					return;
				}
				desc_val = pgm_read_word(list);
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	45 91       	lpm	r20, Z+
    1a5e:	54 91       	lpm	r21, Z
				if (desc_val != wValue) {
    1a60:	40 17       	cp	r20, r16
    1a62:	51 07       	cpc	r21, r17
    1a64:	39 f4       	brne	.+14     	; 0x1a74 <__vector_11+0x9e>
					list += sizeof(struct descriptor_list_struct);
					continue;
				}
				list += 2;
    1a66:	fc 01       	movw	r30, r24
    1a68:	32 96       	adiw	r30, 0x02	; 2
				desc_val = pgm_read_word(list);
    1a6a:	45 91       	lpm	r20, Z+
    1a6c:	54 91       	lpm	r21, Z
				if (desc_val != wIndex) {
    1a6e:	4e 15       	cp	r20, r14
    1a70:	5f 05       	cpc	r21, r15
    1a72:	21 f0       	breq	.+8      	; 0x1a7c <__vector_11+0xa6>
					list += sizeof(struct descriptor_list_struct)-2;
    1a74:	07 96       	adiw	r24, 0x07	; 7
    1a76:	61 50       	subi	r22, 0x01	; 1
                wLength |= (UEDATX << 8);
                UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
                if (bRequest == GET_DESCRIPTOR) {
			list = (const uint8_t *)descriptor_list;
			for (i=0; ; i++) {
				if (i >= NUM_DESC_LIST) {
    1a78:	81 f7       	brne	.-32     	; 0x1a5a <__vector_11+0x84>
    1a7a:	d1 c0       	rjmp	.+418    	; 0x1c1e <__vector_11+0x248>
				desc_val = pgm_read_word(list);
				if (desc_val != wIndex) {
					list += sizeof(struct descriptor_list_struct)-2;
					continue;
				}
				list += 2;
    1a7c:	fc 01       	movw	r30, r24
    1a7e:	34 96       	adiw	r30, 0x04	; 4
				desc_addr = (const uint8_t *)pgm_read_word(list);
    1a80:	45 91       	lpm	r20, Z+
    1a82:	54 91       	lpm	r21, Z
				list += 2;
    1a84:	fc 01       	movw	r30, r24
    1a86:	36 96       	adiw	r30, 0x06	; 6
				desc_length = pgm_read_byte(list);
    1a88:	84 91       	lpm	r24, Z
				break;
			}
			len = (wLength < 256) ? wLength : 255;
    1a8a:	2f 3f       	cpi	r18, 0xFF	; 255
    1a8c:	31 05       	cpc	r19, r1
    1a8e:	19 f0       	breq	.+6      	; 0x1a96 <__vector_11+0xc0>
    1a90:	10 f0       	brcs	.+4      	; 0x1a96 <__vector_11+0xc0>
    1a92:	2f ef       	ldi	r18, 0xFF	; 255
    1a94:	30 e0       	ldi	r19, 0x00	; 0
    1a96:	28 17       	cp	r18, r24
    1a98:	08 f4       	brcc	.+2      	; 0x1a9c <__vector_11+0xc6>
    1a9a:	82 2f       	mov	r24, r18
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
    1a9c:	3e ef       	ldi	r19, 0xFE	; 254
			len = (wLength < 256) ? wLength : 255;
			if (len > desc_length) len = desc_length;
			do {
				// wait for host ready for IN packet
				do {
					i = UEINTX;
    1a9e:	90 91 e8 00 	lds	r25, 0x00E8
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
    1aa2:	29 2f       	mov	r18, r25
    1aa4:	25 70       	andi	r18, 0x05	; 5
    1aa6:	d9 f3       	breq	.-10     	; 0x1a9e <__vector_11+0xc8>
				if (i & (1<<RXOUTI)) return;	// abort
    1aa8:	92 fd       	sbrc	r25, 2
    1aaa:	bc c0       	rjmp	.+376    	; 0x1c24 <__vector_11+0x24e>
				// send IN packet
				n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
    1aac:	98 2f       	mov	r25, r24
    1aae:	81 32       	cpi	r24, 0x21	; 33
    1ab0:	08 f0       	brcs	.+2      	; 0x1ab4 <__vector_11+0xde>
    1ab2:	90 e2       	ldi	r25, 0x20	; 32
				for (i = n; i; i--) {
    1ab4:	fa 01       	movw	r30, r20
    1ab6:	29 2f       	mov	r18, r25
    1ab8:	22 23       	and	r18, r18
    1aba:	31 f0       	breq	.+12     	; 0x1ac8 <__vector_11+0xf2>
					UEDATX = pgm_read_byte(desc_addr++);
    1abc:	64 91       	lpm	r22, Z
    1abe:	60 93 f1 00 	sts	0x00F1, r22
					i = UEINTX;
				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
				if (i & (1<<RXOUTI)) return;	// abort
				// send IN packet
				n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
				for (i = n; i; i--) {
    1ac2:	21 50       	subi	r18, 0x01	; 1
    1ac4:	31 96       	adiw	r30, 0x01	; 1
    1ac6:	f8 cf       	rjmp	.-16     	; 0x1ab8 <__vector_11+0xe2>
    1ac8:	49 0f       	add	r20, r25
    1aca:	51 1d       	adc	r21, r1
					UEDATX = pgm_read_byte(desc_addr++);
				}
				len -= n;
    1acc:	89 1b       	sub	r24, r25
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
    1ace:	30 93 e8 00 	sts	0x00E8, r19
				for (i = n; i; i--) {
					UEDATX = pgm_read_byte(desc_addr++);
				}
				len -= n;
				usb_send_in();
			} while (len || n == ENDPOINT0_SIZE);
    1ad2:	81 11       	cpse	r24, r1
    1ad4:	e4 cf       	rjmp	.-56     	; 0x1a9e <__vector_11+0xc8>
    1ad6:	90 32       	cpi	r25, 0x20	; 32
    1ad8:	11 f3       	breq	.-60     	; 0x1a9e <__vector_11+0xc8>
    1ada:	a4 c0       	rjmp	.+328    	; 0x1c24 <__vector_11+0x24e>
			return;
                }
		if (bRequest == SET_ADDRESS) {
    1adc:	85 30       	cpi	r24, 0x05	; 5
    1ade:	49 f4       	brne	.+18     	; 0x1af2 <__vector_11+0x11c>
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
    1ae0:	8e ef       	ldi	r24, 0xFE	; 254
    1ae2:	80 93 e8 00 	sts	0x00E8, r24
			} while (len || n == ENDPOINT0_SIZE);
			return;
                }
		if (bRequest == SET_ADDRESS) {
			usb_send_in();
			usb_wait_in_ready();
    1ae6:	0e 94 1e 0c 	call	0x183c	; 0x183c <usb_wait_in_ready>
			UDADDR = wValue | (1<<ADDEN);
    1aea:	00 68       	ori	r16, 0x80	; 128
    1aec:	00 93 e3 00 	sts	0x00E3, r16
			return;
    1af0:	99 c0       	rjmp	.+306    	; 0x1c24 <__vector_11+0x24e>
		}
		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
    1af2:	89 30       	cpi	r24, 0x09	; 9
    1af4:	39 f5       	brne	.+78     	; 0x1b44 <__vector_11+0x16e>
    1af6:	91 11       	cpse	r25, r1
    1af8:	4c c0       	rjmp	.+152    	; 0x1b92 <__vector_11+0x1bc>
			usb_configuration = wValue;
    1afa:	00 93 88 01 	sts	0x0188, r16
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
    1afe:	8e ef       	ldi	r24, 0xFE	; 254
    1b00:	80 93 e8 00 	sts	0x00E8, r24
		}
		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
			usb_configuration = wValue;
			usb_send_in();
			cfg = endpoint_config_table;
			for (i=1; i<5; i++) {
    1b04:	41 e0       	ldi	r20, 0x01	; 1
			return;
		}
		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
			usb_configuration = wValue;
			usb_send_in();
			cfg = endpoint_config_table;
    1b06:	8e e4       	ldi	r24, 0x4E	; 78
    1b08:	91 e0       	ldi	r25, 0x01	; 1
			for (i=1; i<5; i++) {
				UENUM = i;
    1b0a:	40 93 e9 00 	sts	0x00E9, r20
				en = pgm_read_byte(cfg++);
    1b0e:	9c 01       	movw	r18, r24
    1b10:	2f 5f       	subi	r18, 0xFF	; 255
    1b12:	3f 4f       	sbci	r19, 0xFF	; 255
    1b14:	fc 01       	movw	r30, r24
    1b16:	54 91       	lpm	r21, Z
				UECONX = en;
    1b18:	50 93 eb 00 	sts	0x00EB, r21
				if (en) {
    1b1c:	55 23       	and	r21, r21
    1b1e:	59 f0       	breq	.+22     	; 0x1b36 <__vector_11+0x160>
					UECFG0X = pgm_read_byte(cfg++);
    1b20:	f9 01       	movw	r30, r18
    1b22:	24 91       	lpm	r18, Z
    1b24:	20 93 ec 00 	sts	0x00EC, r18
					UECFG1X = pgm_read_byte(cfg++);
    1b28:	9c 01       	movw	r18, r24
    1b2a:	2d 5f       	subi	r18, 0xFD	; 253
    1b2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b2e:	31 96       	adiw	r30, 0x01	; 1
    1b30:	84 91       	lpm	r24, Z
    1b32:	80 93 ed 00 	sts	0x00ED, r24
		}
		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
			usb_configuration = wValue;
			usb_send_in();
			cfg = endpoint_config_table;
			for (i=1; i<5; i++) {
    1b36:	4f 5f       	subi	r20, 0xFF	; 255
    1b38:	45 30       	cpi	r20, 0x05	; 5
    1b3a:	11 f0       	breq	.+4      	; 0x1b40 <__vector_11+0x16a>
    1b3c:	c9 01       	movw	r24, r18
    1b3e:	e5 cf       	rjmp	.-54     	; 0x1b0a <__vector_11+0x134>
				if (en) {
					UECFG0X = pgm_read_byte(cfg++);
					UECFG1X = pgm_read_byte(cfg++);
				}
			}
        		UERST = 0x1E;
    1b40:	8e e1       	ldi	r24, 0x1E	; 30
    1b42:	47 c0       	rjmp	.+142    	; 0x1bd2 <__vector_11+0x1fc>
        		UERST = 0;
			return;
		}
		if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {
    1b44:	88 30       	cpi	r24, 0x08	; 8
    1b46:	51 f4       	brne	.+20     	; 0x1b5c <__vector_11+0x186>
    1b48:	90 38       	cpi	r25, 0x80	; 128
    1b4a:	09 f0       	breq	.+2      	; 0x1b4e <__vector_11+0x178>
    1b4c:	68 c0       	rjmp	.+208    	; 0x1c1e <__vector_11+0x248>
			usb_wait_in_ready();
    1b4e:	0e 94 1e 0c 	call	0x183c	; 0x183c <usb_wait_in_ready>
			UEDATX = usb_configuration;
    1b52:	80 91 88 01 	lds	r24, 0x0188
    1b56:	80 93 f1 00 	sts	0x00F1, r24
    1b5a:	17 c0       	rjmp	.+46     	; 0x1b8a <__vector_11+0x1b4>
			usb_send_in();
			return;
		}

		if (bRequest == GET_STATUS) {
    1b5c:	81 11       	cpse	r24, r1
    1b5e:	19 c0       	rjmp	.+50     	; 0x1b92 <__vector_11+0x1bc>
			usb_wait_in_ready();
    1b60:	99 83       	std	Y+1, r25	; 0x01
    1b62:	0e 94 1e 0c 	call	0x183c	; 0x183c <usb_wait_in_ready>
			i = 0;
			#ifdef SUPPORT_ENDPOINT_HALT
			if (bmRequestType == 0x82) {
    1b66:	99 81       	ldd	r25, Y+1	; 0x01
    1b68:	92 38       	cpi	r25, 0x82	; 130
    1b6a:	51 f4       	brne	.+20     	; 0x1b80 <__vector_11+0x1aa>
				UENUM = wIndex;
    1b6c:	e0 92 e9 00 	sts	0x00E9, r14
				if (UECONX & (1<<STALLRQ)) i = 1;
    1b70:	80 91 eb 00 	lds	r24, 0x00EB
    1b74:	85 fb       	bst	r24, 5
    1b76:	88 27       	eor	r24, r24
    1b78:	80 f9       	bld	r24, 0
				UENUM = 0;
    1b7a:	10 92 e9 00 	sts	0x00E9, r1
    1b7e:	01 c0       	rjmp	.+2      	; 0x1b82 <__vector_11+0x1ac>
			return;
		}

		if (bRequest == GET_STATUS) {
			usb_wait_in_ready();
			i = 0;
    1b80:	80 e0       	ldi	r24, 0x00	; 0
				UENUM = wIndex;
				if (UECONX & (1<<STALLRQ)) i = 1;
				UENUM = 0;
			}
			#endif
			UEDATX = i;
    1b82:	80 93 f1 00 	sts	0x00F1, r24
			UEDATX = 0;
    1b86:	10 92 f1 00 	sts	0x00F1, r1
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
    1b8a:	8e ef       	ldi	r24, 0xFE	; 254
    1b8c:	80 93 e8 00 	sts	0x00E8, r24
    1b90:	49 c0       	rjmp	.+146    	; 0x1c24 <__vector_11+0x24e>
			UEDATX = 0;
			usb_send_in();
			return;
		}
		#ifdef SUPPORT_ENDPOINT_HALT
		if ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)
    1b92:	48 2f       	mov	r20, r24
    1b94:	4d 7f       	andi	r20, 0xFD	; 253
    1b96:	41 30       	cpi	r20, 0x01	; 1
    1b98:	09 f0       	breq	.+2      	; 0x1b9c <__vector_11+0x1c6>
    1b9a:	41 c0       	rjmp	.+130    	; 0x1c1e <__vector_11+0x248>
		  && bmRequestType == 0x02 && wValue == 0) {
    1b9c:	92 30       	cpi	r25, 0x02	; 2
    1b9e:	f1 f4       	brne	.+60     	; 0x1bdc <__vector_11+0x206>
    1ba0:	01 2b       	or	r16, r17
    1ba2:	e9 f5       	brne	.+122    	; 0x1c1e <__vector_11+0x248>
			i = wIndex & 0x7F;
    1ba4:	2e 2d       	mov	r18, r14
    1ba6:	2f 77       	andi	r18, 0x7F	; 127
			if (i >= 1 && i <= MAX_ENDPOINT) {
    1ba8:	9f ef       	ldi	r25, 0xFF	; 255
    1baa:	92 0f       	add	r25, r18
    1bac:	94 30       	cpi	r25, 0x04	; 4
    1bae:	b8 f5       	brcc	.+110    	; 0x1c1e <__vector_11+0x248>
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
    1bb0:	9e ef       	ldi	r25, 0xFE	; 254
    1bb2:	90 93 e8 00 	sts	0x00E8, r25
		if ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)
		  && bmRequestType == 0x02 && wValue == 0) {
			i = wIndex & 0x7F;
			if (i >= 1 && i <= MAX_ENDPOINT) {
				usb_send_in();
				UENUM = i;
    1bb6:	20 93 e9 00 	sts	0x00E9, r18
				if (bRequest == SET_FEATURE) {
    1bba:	83 30       	cpi	r24, 0x03	; 3
    1bbc:	81 f1       	breq	.+96     	; 0x1c1e <__vector_11+0x248>
					UECONX = (1<<STALLRQ)|(1<<EPEN);
				} else {
					UECONX = (1<<STALLRQC)|(1<<RSTDT)|(1<<EPEN);
    1bbe:	89 e1       	ldi	r24, 0x19	; 25
    1bc0:	80 93 eb 00 	sts	0x00EB, r24
					UERST = (1 << i);
    1bc4:	81 e0       	ldi	r24, 0x01	; 1
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	02 2e       	mov	r0, r18
    1bca:	01 c0       	rjmp	.+2      	; 0x1bce <__vector_11+0x1f8>
    1bcc:	88 0f       	add	r24, r24
    1bce:	0a 94       	dec	r0
    1bd0:	ea f7       	brpl	.-6      	; 0x1bcc <__vector_11+0x1f6>
    1bd2:	80 93 ea 00 	sts	0x00EA, r24
					UERST = 0;
    1bd6:	10 92 ea 00 	sts	0x00EA, r1
    1bda:	24 c0       	rjmp	.+72     	; 0x1c24 <__vector_11+0x24e>
				}
				return;
			}
		}
		#endif
		if (bRequest == HID_GET_REPORT && bmRequestType == 0xA1) {
    1bdc:	81 30       	cpi	r24, 0x01	; 1
    1bde:	f9 f4       	brne	.+62     	; 0x1c1e <__vector_11+0x248>
    1be0:	91 3a       	cpi	r25, 0xA1	; 161
    1be2:	e9 f4       	brne	.+58     	; 0x1c1e <__vector_11+0x248>
			if (wIndex == 0) {
    1be4:	ef 28       	or	r14, r15
    1be6:	d9 f4       	brne	.+54     	; 0x1c1e <__vector_11+0x248>
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
    1be8:	3e ef       	ldi	r19, 0xFE	; 254
			if (wIndex == 0) {
				len = wLength;
				do {
					// wait for host ready for IN packet
					do {
						i = UEINTX;
    1bea:	80 91 e8 00 	lds	r24, 0x00E8
					} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
    1bee:	98 2f       	mov	r25, r24
    1bf0:	95 70       	andi	r25, 0x05	; 5
    1bf2:	d9 f3       	breq	.-10     	; 0x1bea <__vector_11+0x214>
					if (i & (1<<RXOUTI)) return;	// abort
    1bf4:	82 fd       	sbrc	r24, 2
    1bf6:	16 c0       	rjmp	.+44     	; 0x1c24 <__vector_11+0x24e>
					// send IN packet
					n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
    1bf8:	82 2f       	mov	r24, r18
    1bfa:	21 32       	cpi	r18, 0x21	; 33
    1bfc:	08 f0       	brcs	.+2      	; 0x1c00 <__vector_11+0x22a>
    1bfe:	80 e2       	ldi	r24, 0x20	; 32
					for (i = n; i; i--) {
    1c00:	98 2f       	mov	r25, r24
    1c02:	99 23       	and	r25, r25
    1c04:	21 f0       	breq	.+8      	; 0x1c0e <__vector_11+0x238>
						UEDATX = 0;
    1c06:	10 92 f1 00 	sts	0x00F1, r1
						i = UEINTX;
					} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
					if (i & (1<<RXOUTI)) return;	// abort
					// send IN packet
					n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
					for (i = n; i; i--) {
    1c0a:	91 50       	subi	r25, 0x01	; 1
    1c0c:	fa cf       	rjmp	.-12     	; 0x1c02 <__vector_11+0x22c>
						UEDATX = 0;
					}
					len -= n;
    1c0e:	28 1b       	sub	r18, r24
{
	while (!(UEINTX & (1<<TXINI))) ;
}
static inline void usb_send_in(void)
{
	UEINTX = ~(1<<TXINI);
    1c10:	30 93 e8 00 	sts	0x00E8, r19
					for (i = n; i; i--) {
						UEDATX = 0;
					}
					len -= n;
					usb_send_in();
				} while (len || n == ENDPOINT0_SIZE);
    1c14:	21 11       	cpse	r18, r1
    1c16:	e9 cf       	rjmp	.-46     	; 0x1bea <__vector_11+0x214>
    1c18:	80 32       	cpi	r24, 0x20	; 32
    1c1a:	39 f3       	breq	.-50     	; 0x1bea <__vector_11+0x214>
    1c1c:	03 c0       	rjmp	.+6      	; 0x1c24 <__vector_11+0x24e>
				return;
			}
		}
        }
	UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
    1c1e:	81 e2       	ldi	r24, 0x21	; 33
    1c20:	80 93 eb 00 	sts	0x00EB, r24
}
    1c24:	0f 90       	pop	r0
    1c26:	df 91       	pop	r29
    1c28:	cf 91       	pop	r28
    1c2a:	ff 91       	pop	r31
    1c2c:	ef 91       	pop	r30
    1c2e:	bf 91       	pop	r27
    1c30:	af 91       	pop	r26
    1c32:	9f 91       	pop	r25
    1c34:	8f 91       	pop	r24
    1c36:	7f 91       	pop	r23
    1c38:	6f 91       	pop	r22
    1c3a:	5f 91       	pop	r21
    1c3c:	4f 91       	pop	r20
    1c3e:	3f 91       	pop	r19
    1c40:	2f 91       	pop	r18
    1c42:	1f 91       	pop	r17
    1c44:	0f 91       	pop	r16
    1c46:	ff 90       	pop	r15
    1c48:	ef 90       	pop	r14
    1c4a:	0f 90       	pop	r0
    1c4c:	0b be       	out	0x3b, r0	; 59
    1c4e:	0f 90       	pop	r0
    1c50:	0f be       	out	0x3f, r0	; 63
    1c52:	0f 90       	pop	r0
    1c54:	1f 90       	pop	r1
    1c56:	18 95       	reti

00001c58 <byte_to_binary>:
//

#include <stdio.h>

void byte_to_binary(char* b, uint8_t x) {
    for (int i = 7; i >= 0; i--) {
    1c58:	27 e0       	ldi	r18, 0x07	; 7
    1c5a:	30 e0       	ldi	r19, 0x00	; 0
        b[i] = x >> i & 0x01 ? '1' : '0';
    1c5c:	70 e0       	ldi	r23, 0x00	; 0
    1c5e:	ab 01       	movw	r20, r22
    1c60:	02 2e       	mov	r0, r18
    1c62:	02 c0       	rjmp	.+4      	; 0x1c68 <byte_to_binary+0x10>
    1c64:	55 95       	asr	r21
    1c66:	47 95       	ror	r20
    1c68:	0a 94       	dec	r0
    1c6a:	e2 f7       	brpl	.-8      	; 0x1c64 <byte_to_binary+0xc>
    1c6c:	40 ff       	sbrs	r20, 0
    1c6e:	02 c0       	rjmp	.+4      	; 0x1c74 <byte_to_binary+0x1c>
    1c70:	41 e3       	ldi	r20, 0x31	; 49
    1c72:	01 c0       	rjmp	.+2      	; 0x1c76 <byte_to_binary+0x1e>
    1c74:	40 e3       	ldi	r20, 0x30	; 48
    1c76:	fc 01       	movw	r30, r24
    1c78:	e2 0f       	add	r30, r18
    1c7a:	f3 1f       	adc	r31, r19
    1c7c:	40 83       	st	Z, r20
//

#include <stdio.h>

void byte_to_binary(char* b, uint8_t x) {
    for (int i = 7; i >= 0; i--) {
    1c7e:	21 50       	subi	r18, 0x01	; 1
    1c80:	31 09       	sbc	r19, r1
    1c82:	68 f7       	brcc	.-38     	; 0x1c5e <byte_to_binary+0x6>
        b[i] = x >> i & 0x01 ? '1' : '0';
    }
    b[8] = '\0';
    1c84:	fc 01       	movw	r30, r24
    1c86:	10 86       	std	Z+8, r1	; 0x08
    1c88:	08 95       	ret

00001c8a <zstrlen>:
    1c8a:	fc 01       	movw	r30, r24
    1c8c:	80 e0       	ldi	r24, 0x00	; 0
    1c8e:	91 91       	ld	r25, Z+
    1c90:	99 23       	and	r25, r25
    1c92:	19 f0       	breq	.+6      	; 0x1c9a <zstrlen+0x10>
    1c94:	8f 5f       	subi	r24, 0xFF	; 255
    1c96:	8f 3f       	cpi	r24, 0xFF	; 255
    1c98:	d1 f7       	brne	.-12     	; 0x1c8e <zstrlen+0x4>
    1c9a:	08 95       	ret

00001c9c <main>:

int main(void) {
    1c9c:	cf 93       	push	r28
    1c9e:	df 93       	push	r29
    1ca0:	cd b7       	in	r28, 0x3d	; 61
    1ca2:	de b7       	in	r29, 0x3e	; 62
    1ca4:	ca 58       	subi	r28, 0x8A	; 138
    1ca6:	d1 09       	sbc	r29, r1
    1ca8:	0f b6       	in	r0, 0x3f	; 63
    1caa:	f8 94       	cli
    1cac:	de bf       	out	0x3e, r29	; 62
    1cae:	0f be       	out	0x3f, r0	; 63
    1cb0:	cd bf       	out	0x3d, r28	; 61
    CPU_PRESCALE(CPU_16MHz);
    1cb2:	80 e8       	ldi	r24, 0x80	; 128
    1cb4:	80 93 61 00 	sts	0x0061, r24
    1cb8:	10 92 61 00 	sts	0x0061, r1
    usb_init();
    1cbc:	0e 94 23 0c 	call	0x1846	; 0x1846 <usb_init>
    while (!usb_configured()) {
    1cc0:	0e 94 3a 0c 	call	0x1874	; 0x1874 <usb_configured>
    1cc4:	88 23       	and	r24, r24
    1cc6:	e1 f3       	breq	.-8      	; 0x1cc0 <main+0x24>
        continue;
    }
    timer = time_make(0, 0, 0, 0);
    1cc8:	20 e0       	ldi	r18, 0x00	; 0
    1cca:	30 e0       	ldi	r19, 0x00	; 0
    1ccc:	40 e0       	ldi	r20, 0x00	; 0
    1cce:	50 e0       	ldi	r21, 0x00	; 0
    1cd0:	60 e0       	ldi	r22, 0x00	; 0
    1cd2:	70 e0       	ldi	r23, 0x00	; 0
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <time_make>
    1cdc:	20 93 89 01 	sts	0x0189, r18
    1ce0:	30 93 8a 01 	sts	0x018A, r19
    1ce4:	40 93 8b 01 	sts	0x018B, r20
    1ce8:	50 93 8c 01 	sts	0x018C, r21
    1cec:	60 93 8d 01 	sts	0x018D, r22
    1cf0:	70 93 8e 01 	sts	0x018E, r23
    1cf4:	80 93 8f 01 	sts	0x018F, r24
    1cf8:	90 93 90 01 	sts	0x0190, r25
    timer_start();
    1cfc:	0e 94 da 03 	call	0x7b4	; 0x7b4 <timer_start>
    
    foodunit f;
    foodunit_init(&f);
    1d00:	ce 01       	movw	r24, r28
    1d02:	01 96       	adiw	r24, 0x01	; 1
    1d04:	0e 94 0d 05 	call	0xa1a	; 0xa1a <foodunit_init>
    while (1) {
        foodunit_update(&f);
    1d08:	ce 01       	movw	r24, r28
    1d0a:	01 96       	adiw	r24, 0x01	; 1
    1d0c:	0e 94 3d 07 	call	0xe7a	; 0xe7a <foodunit_update>
    1d10:	fb cf       	rjmp	.-10     	; 0x1d08 <main+0x6c>

00001d12 <__divmodhi4>:
    1d12:	97 fb       	bst	r25, 7
    1d14:	07 2e       	mov	r0, r23
    1d16:	16 f4       	brtc	.+4      	; 0x1d1c <__divmodhi4+0xa>
    1d18:	00 94       	com	r0
    1d1a:	07 d0       	rcall	.+14     	; 0x1d2a <__divmodhi4_neg1>
    1d1c:	77 fd       	sbrc	r23, 7
    1d1e:	09 d0       	rcall	.+18     	; 0x1d32 <__divmodhi4_neg2>
    1d20:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <__udivmodhi4>
    1d24:	07 fc       	sbrc	r0, 7
    1d26:	05 d0       	rcall	.+10     	; 0x1d32 <__divmodhi4_neg2>
    1d28:	3e f4       	brtc	.+14     	; 0x1d38 <__divmodhi4_exit>

00001d2a <__divmodhi4_neg1>:
    1d2a:	90 95       	com	r25
    1d2c:	81 95       	neg	r24
    1d2e:	9f 4f       	sbci	r25, 0xFF	; 255
    1d30:	08 95       	ret

00001d32 <__divmodhi4_neg2>:
    1d32:	70 95       	com	r23
    1d34:	61 95       	neg	r22
    1d36:	7f 4f       	sbci	r23, 0xFF	; 255

00001d38 <__divmodhi4_exit>:
    1d38:	08 95       	ret

00001d3a <__udivmodhi4>:
    1d3a:	aa 1b       	sub	r26, r26
    1d3c:	bb 1b       	sub	r27, r27
    1d3e:	51 e1       	ldi	r21, 0x11	; 17
    1d40:	07 c0       	rjmp	.+14     	; 0x1d50 <__udivmodhi4_ep>

00001d42 <__udivmodhi4_loop>:
    1d42:	aa 1f       	adc	r26, r26
    1d44:	bb 1f       	adc	r27, r27
    1d46:	a6 17       	cp	r26, r22
    1d48:	b7 07       	cpc	r27, r23
    1d4a:	10 f0       	brcs	.+4      	; 0x1d50 <__udivmodhi4_ep>
    1d4c:	a6 1b       	sub	r26, r22
    1d4e:	b7 0b       	sbc	r27, r23

00001d50 <__udivmodhi4_ep>:
    1d50:	88 1f       	adc	r24, r24
    1d52:	99 1f       	adc	r25, r25
    1d54:	5a 95       	dec	r21
    1d56:	a9 f7       	brne	.-22     	; 0x1d42 <__udivmodhi4_loop>
    1d58:	80 95       	com	r24
    1d5a:	90 95       	com	r25
    1d5c:	bc 01       	movw	r22, r24
    1d5e:	cd 01       	movw	r24, r26
    1d60:	08 95       	ret

00001d62 <sprintf>:
    1d62:	0f 93       	push	r16
    1d64:	1f 93       	push	r17
    1d66:	cf 93       	push	r28
    1d68:	df 93       	push	r29
    1d6a:	cd b7       	in	r28, 0x3d	; 61
    1d6c:	de b7       	in	r29, 0x3e	; 62
    1d6e:	2e 97       	sbiw	r28, 0x0e	; 14
    1d70:	0f b6       	in	r0, 0x3f	; 63
    1d72:	f8 94       	cli
    1d74:	de bf       	out	0x3e, r29	; 62
    1d76:	0f be       	out	0x3f, r0	; 63
    1d78:	cd bf       	out	0x3d, r28	; 61
    1d7a:	0d 89       	ldd	r16, Y+21	; 0x15
    1d7c:	1e 89       	ldd	r17, Y+22	; 0x16
    1d7e:	86 e0       	ldi	r24, 0x06	; 6
    1d80:	8c 83       	std	Y+4, r24	; 0x04
    1d82:	1a 83       	std	Y+2, r17	; 0x02
    1d84:	09 83       	std	Y+1, r16	; 0x01
    1d86:	8f ef       	ldi	r24, 0xFF	; 255
    1d88:	9f e7       	ldi	r25, 0x7F	; 127
    1d8a:	9e 83       	std	Y+6, r25	; 0x06
    1d8c:	8d 83       	std	Y+5, r24	; 0x05
    1d8e:	ae 01       	movw	r20, r28
    1d90:	47 5e       	subi	r20, 0xE7	; 231
    1d92:	5f 4f       	sbci	r21, 0xFF	; 255
    1d94:	6f 89       	ldd	r22, Y+23	; 0x17
    1d96:	78 8d       	ldd	r23, Y+24	; 0x18
    1d98:	ce 01       	movw	r24, r28
    1d9a:	01 96       	adiw	r24, 0x01	; 1
    1d9c:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <vfprintf>
    1da0:	ef 81       	ldd	r30, Y+7	; 0x07
    1da2:	f8 85       	ldd	r31, Y+8	; 0x08
    1da4:	e0 0f       	add	r30, r16
    1da6:	f1 1f       	adc	r31, r17
    1da8:	10 82       	st	Z, r1
    1daa:	2e 96       	adiw	r28, 0x0e	; 14
    1dac:	0f b6       	in	r0, 0x3f	; 63
    1dae:	f8 94       	cli
    1db0:	de bf       	out	0x3e, r29	; 62
    1db2:	0f be       	out	0x3f, r0	; 63
    1db4:	cd bf       	out	0x3d, r28	; 61
    1db6:	df 91       	pop	r29
    1db8:	cf 91       	pop	r28
    1dba:	1f 91       	pop	r17
    1dbc:	0f 91       	pop	r16
    1dbe:	08 95       	ret

00001dc0 <vfprintf>:
    1dc0:	2f 92       	push	r2
    1dc2:	3f 92       	push	r3
    1dc4:	4f 92       	push	r4
    1dc6:	5f 92       	push	r5
    1dc8:	6f 92       	push	r6
    1dca:	7f 92       	push	r7
    1dcc:	8f 92       	push	r8
    1dce:	9f 92       	push	r9
    1dd0:	af 92       	push	r10
    1dd2:	bf 92       	push	r11
    1dd4:	cf 92       	push	r12
    1dd6:	df 92       	push	r13
    1dd8:	ef 92       	push	r14
    1dda:	ff 92       	push	r15
    1ddc:	0f 93       	push	r16
    1dde:	1f 93       	push	r17
    1de0:	cf 93       	push	r28
    1de2:	df 93       	push	r29
    1de4:	cd b7       	in	r28, 0x3d	; 61
    1de6:	de b7       	in	r29, 0x3e	; 62
    1de8:	2c 97       	sbiw	r28, 0x0c	; 12
    1dea:	0f b6       	in	r0, 0x3f	; 63
    1dec:	f8 94       	cli
    1dee:	de bf       	out	0x3e, r29	; 62
    1df0:	0f be       	out	0x3f, r0	; 63
    1df2:	cd bf       	out	0x3d, r28	; 61
    1df4:	7c 01       	movw	r14, r24
    1df6:	6b 01       	movw	r12, r22
    1df8:	8a 01       	movw	r16, r20
    1dfa:	fc 01       	movw	r30, r24
    1dfc:	17 82       	std	Z+7, r1	; 0x07
    1dfe:	16 82       	std	Z+6, r1	; 0x06
    1e00:	83 81       	ldd	r24, Z+3	; 0x03
    1e02:	81 ff       	sbrs	r24, 1
    1e04:	bd c1       	rjmp	.+890    	; 0x2180 <__stack+0x81>
    1e06:	ce 01       	movw	r24, r28
    1e08:	01 96       	adiw	r24, 0x01	; 1
    1e0a:	4c 01       	movw	r8, r24
    1e0c:	f7 01       	movw	r30, r14
    1e0e:	93 81       	ldd	r25, Z+3	; 0x03
    1e10:	f6 01       	movw	r30, r12
    1e12:	93 fd       	sbrc	r25, 3
    1e14:	85 91       	lpm	r24, Z+
    1e16:	93 ff       	sbrs	r25, 3
    1e18:	81 91       	ld	r24, Z+
    1e1a:	6f 01       	movw	r12, r30
    1e1c:	88 23       	and	r24, r24
    1e1e:	09 f4       	brne	.+2      	; 0x1e22 <vfprintf+0x62>
    1e20:	ab c1       	rjmp	.+854    	; 0x2178 <__stack+0x79>
    1e22:	85 32       	cpi	r24, 0x25	; 37
    1e24:	39 f4       	brne	.+14     	; 0x1e34 <vfprintf+0x74>
    1e26:	93 fd       	sbrc	r25, 3
    1e28:	85 91       	lpm	r24, Z+
    1e2a:	93 ff       	sbrs	r25, 3
    1e2c:	81 91       	ld	r24, Z+
    1e2e:	6f 01       	movw	r12, r30
    1e30:	85 32       	cpi	r24, 0x25	; 37
    1e32:	29 f4       	brne	.+10     	; 0x1e3e <vfprintf+0x7e>
    1e34:	b7 01       	movw	r22, r14
    1e36:	90 e0       	ldi	r25, 0x00	; 0
    1e38:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <fputc>
    1e3c:	e7 cf       	rjmp	.-50     	; 0x1e0c <vfprintf+0x4c>
    1e3e:	51 2c       	mov	r5, r1
    1e40:	31 2c       	mov	r3, r1
    1e42:	20 e0       	ldi	r18, 0x00	; 0
    1e44:	20 32       	cpi	r18, 0x20	; 32
    1e46:	a0 f4       	brcc	.+40     	; 0x1e70 <vfprintf+0xb0>
    1e48:	8b 32       	cpi	r24, 0x2B	; 43
    1e4a:	69 f0       	breq	.+26     	; 0x1e66 <vfprintf+0xa6>
    1e4c:	30 f4       	brcc	.+12     	; 0x1e5a <vfprintf+0x9a>
    1e4e:	80 32       	cpi	r24, 0x20	; 32
    1e50:	59 f0       	breq	.+22     	; 0x1e68 <vfprintf+0xa8>
    1e52:	83 32       	cpi	r24, 0x23	; 35
    1e54:	69 f4       	brne	.+26     	; 0x1e70 <vfprintf+0xb0>
    1e56:	20 61       	ori	r18, 0x10	; 16
    1e58:	2c c0       	rjmp	.+88     	; 0x1eb2 <vfprintf+0xf2>
    1e5a:	8d 32       	cpi	r24, 0x2D	; 45
    1e5c:	39 f0       	breq	.+14     	; 0x1e6c <vfprintf+0xac>
    1e5e:	80 33       	cpi	r24, 0x30	; 48
    1e60:	39 f4       	brne	.+14     	; 0x1e70 <vfprintf+0xb0>
    1e62:	21 60       	ori	r18, 0x01	; 1
    1e64:	26 c0       	rjmp	.+76     	; 0x1eb2 <vfprintf+0xf2>
    1e66:	22 60       	ori	r18, 0x02	; 2
    1e68:	24 60       	ori	r18, 0x04	; 4
    1e6a:	23 c0       	rjmp	.+70     	; 0x1eb2 <vfprintf+0xf2>
    1e6c:	28 60       	ori	r18, 0x08	; 8
    1e6e:	21 c0       	rjmp	.+66     	; 0x1eb2 <vfprintf+0xf2>
    1e70:	27 fd       	sbrc	r18, 7
    1e72:	27 c0       	rjmp	.+78     	; 0x1ec2 <vfprintf+0x102>
    1e74:	30 ed       	ldi	r19, 0xD0	; 208
    1e76:	38 0f       	add	r19, r24
    1e78:	3a 30       	cpi	r19, 0x0A	; 10
    1e7a:	78 f4       	brcc	.+30     	; 0x1e9a <vfprintf+0xda>
    1e7c:	26 ff       	sbrs	r18, 6
    1e7e:	06 c0       	rjmp	.+12     	; 0x1e8c <vfprintf+0xcc>
    1e80:	fa e0       	ldi	r31, 0x0A	; 10
    1e82:	5f 9e       	mul	r5, r31
    1e84:	30 0d       	add	r19, r0
    1e86:	11 24       	eor	r1, r1
    1e88:	53 2e       	mov	r5, r19
    1e8a:	13 c0       	rjmp	.+38     	; 0x1eb2 <vfprintf+0xf2>
    1e8c:	8a e0       	ldi	r24, 0x0A	; 10
    1e8e:	38 9e       	mul	r3, r24
    1e90:	30 0d       	add	r19, r0
    1e92:	11 24       	eor	r1, r1
    1e94:	33 2e       	mov	r3, r19
    1e96:	20 62       	ori	r18, 0x20	; 32
    1e98:	0c c0       	rjmp	.+24     	; 0x1eb2 <vfprintf+0xf2>
    1e9a:	8e 32       	cpi	r24, 0x2E	; 46
    1e9c:	21 f4       	brne	.+8      	; 0x1ea6 <vfprintf+0xe6>
    1e9e:	26 fd       	sbrc	r18, 6
    1ea0:	6b c1       	rjmp	.+726    	; 0x2178 <__stack+0x79>
    1ea2:	20 64       	ori	r18, 0x40	; 64
    1ea4:	06 c0       	rjmp	.+12     	; 0x1eb2 <vfprintf+0xf2>
    1ea6:	8c 36       	cpi	r24, 0x6C	; 108
    1ea8:	11 f4       	brne	.+4      	; 0x1eae <vfprintf+0xee>
    1eaa:	20 68       	ori	r18, 0x80	; 128
    1eac:	02 c0       	rjmp	.+4      	; 0x1eb2 <vfprintf+0xf2>
    1eae:	88 36       	cpi	r24, 0x68	; 104
    1eb0:	41 f4       	brne	.+16     	; 0x1ec2 <vfprintf+0x102>
    1eb2:	f6 01       	movw	r30, r12
    1eb4:	93 fd       	sbrc	r25, 3
    1eb6:	85 91       	lpm	r24, Z+
    1eb8:	93 ff       	sbrs	r25, 3
    1eba:	81 91       	ld	r24, Z+
    1ebc:	6f 01       	movw	r12, r30
    1ebe:	81 11       	cpse	r24, r1
    1ec0:	c1 cf       	rjmp	.-126    	; 0x1e44 <vfprintf+0x84>
    1ec2:	98 2f       	mov	r25, r24
    1ec4:	9f 7d       	andi	r25, 0xDF	; 223
    1ec6:	95 54       	subi	r25, 0x45	; 69
    1ec8:	93 30       	cpi	r25, 0x03	; 3
    1eca:	28 f4       	brcc	.+10     	; 0x1ed6 <vfprintf+0x116>
    1ecc:	0c 5f       	subi	r16, 0xFC	; 252
    1ece:	1f 4f       	sbci	r17, 0xFF	; 255
    1ed0:	ff e3       	ldi	r31, 0x3F	; 63
    1ed2:	f9 83       	std	Y+1, r31	; 0x01
    1ed4:	0d c0       	rjmp	.+26     	; 0x1ef0 <vfprintf+0x130>
    1ed6:	83 36       	cpi	r24, 0x63	; 99
    1ed8:	31 f0       	breq	.+12     	; 0x1ee6 <vfprintf+0x126>
    1eda:	83 37       	cpi	r24, 0x73	; 115
    1edc:	71 f0       	breq	.+28     	; 0x1efa <vfprintf+0x13a>
    1ede:	83 35       	cpi	r24, 0x53	; 83
    1ee0:	09 f0       	breq	.+2      	; 0x1ee4 <vfprintf+0x124>
    1ee2:	5b c0       	rjmp	.+182    	; 0x1f9a <vfprintf+0x1da>
    1ee4:	22 c0       	rjmp	.+68     	; 0x1f2a <vfprintf+0x16a>
    1ee6:	f8 01       	movw	r30, r16
    1ee8:	80 81       	ld	r24, Z
    1eea:	89 83       	std	Y+1, r24	; 0x01
    1eec:	0e 5f       	subi	r16, 0xFE	; 254
    1eee:	1f 4f       	sbci	r17, 0xFF	; 255
    1ef0:	44 24       	eor	r4, r4
    1ef2:	43 94       	inc	r4
    1ef4:	51 2c       	mov	r5, r1
    1ef6:	54 01       	movw	r10, r8
    1ef8:	15 c0       	rjmp	.+42     	; 0x1f24 <vfprintf+0x164>
    1efa:	38 01       	movw	r6, r16
    1efc:	f2 e0       	ldi	r31, 0x02	; 2
    1efe:	6f 0e       	add	r6, r31
    1f00:	71 1c       	adc	r7, r1
    1f02:	f8 01       	movw	r30, r16
    1f04:	a0 80       	ld	r10, Z
    1f06:	b1 80       	ldd	r11, Z+1	; 0x01
    1f08:	26 ff       	sbrs	r18, 6
    1f0a:	03 c0       	rjmp	.+6      	; 0x1f12 <vfprintf+0x152>
    1f0c:	65 2d       	mov	r22, r5
    1f0e:	70 e0       	ldi	r23, 0x00	; 0
    1f10:	02 c0       	rjmp	.+4      	; 0x1f16 <vfprintf+0x156>
    1f12:	6f ef       	ldi	r22, 0xFF	; 255
    1f14:	7f ef       	ldi	r23, 0xFF	; 255
    1f16:	c5 01       	movw	r24, r10
    1f18:	2c 87       	std	Y+12, r18	; 0x0c
    1f1a:	0e 94 e6 10 	call	0x21cc	; 0x21cc <strnlen>
    1f1e:	2c 01       	movw	r4, r24
    1f20:	83 01       	movw	r16, r6
    1f22:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f24:	2f 77       	andi	r18, 0x7F	; 127
    1f26:	22 2e       	mov	r2, r18
    1f28:	17 c0       	rjmp	.+46     	; 0x1f58 <vfprintf+0x198>
    1f2a:	38 01       	movw	r6, r16
    1f2c:	f2 e0       	ldi	r31, 0x02	; 2
    1f2e:	6f 0e       	add	r6, r31
    1f30:	71 1c       	adc	r7, r1
    1f32:	f8 01       	movw	r30, r16
    1f34:	a0 80       	ld	r10, Z
    1f36:	b1 80       	ldd	r11, Z+1	; 0x01
    1f38:	26 ff       	sbrs	r18, 6
    1f3a:	03 c0       	rjmp	.+6      	; 0x1f42 <vfprintf+0x182>
    1f3c:	65 2d       	mov	r22, r5
    1f3e:	70 e0       	ldi	r23, 0x00	; 0
    1f40:	02 c0       	rjmp	.+4      	; 0x1f46 <vfprintf+0x186>
    1f42:	6f ef       	ldi	r22, 0xFF	; 255
    1f44:	7f ef       	ldi	r23, 0xFF	; 255
    1f46:	c5 01       	movw	r24, r10
    1f48:	2c 87       	std	Y+12, r18	; 0x0c
    1f4a:	0e 94 db 10 	call	0x21b6	; 0x21b6 <strnlen_P>
    1f4e:	2c 01       	movw	r4, r24
    1f50:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f52:	20 68       	ori	r18, 0x80	; 128
    1f54:	22 2e       	mov	r2, r18
    1f56:	83 01       	movw	r16, r6
    1f58:	23 fc       	sbrc	r2, 3
    1f5a:	1b c0       	rjmp	.+54     	; 0x1f92 <vfprintf+0x1d2>
    1f5c:	83 2d       	mov	r24, r3
    1f5e:	90 e0       	ldi	r25, 0x00	; 0
    1f60:	48 16       	cp	r4, r24
    1f62:	59 06       	cpc	r5, r25
    1f64:	b0 f4       	brcc	.+44     	; 0x1f92 <vfprintf+0x1d2>
    1f66:	b7 01       	movw	r22, r14
    1f68:	80 e2       	ldi	r24, 0x20	; 32
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <fputc>
    1f70:	3a 94       	dec	r3
    1f72:	f4 cf       	rjmp	.-24     	; 0x1f5c <vfprintf+0x19c>
    1f74:	f5 01       	movw	r30, r10
    1f76:	27 fc       	sbrc	r2, 7
    1f78:	85 91       	lpm	r24, Z+
    1f7a:	27 fe       	sbrs	r2, 7
    1f7c:	81 91       	ld	r24, Z+
    1f7e:	5f 01       	movw	r10, r30
    1f80:	b7 01       	movw	r22, r14
    1f82:	90 e0       	ldi	r25, 0x00	; 0
    1f84:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <fputc>
    1f88:	31 10       	cpse	r3, r1
    1f8a:	3a 94       	dec	r3
    1f8c:	f1 e0       	ldi	r31, 0x01	; 1
    1f8e:	4f 1a       	sub	r4, r31
    1f90:	51 08       	sbc	r5, r1
    1f92:	41 14       	cp	r4, r1
    1f94:	51 04       	cpc	r5, r1
    1f96:	71 f7       	brne	.-36     	; 0x1f74 <vfprintf+0x1b4>
    1f98:	e5 c0       	rjmp	.+458    	; 0x2164 <__stack+0x65>
    1f9a:	84 36       	cpi	r24, 0x64	; 100
    1f9c:	11 f0       	breq	.+4      	; 0x1fa2 <vfprintf+0x1e2>
    1f9e:	89 36       	cpi	r24, 0x69	; 105
    1fa0:	39 f5       	brne	.+78     	; 0x1ff0 <vfprintf+0x230>
    1fa2:	f8 01       	movw	r30, r16
    1fa4:	27 ff       	sbrs	r18, 7
    1fa6:	07 c0       	rjmp	.+14     	; 0x1fb6 <vfprintf+0x1f6>
    1fa8:	60 81       	ld	r22, Z
    1faa:	71 81       	ldd	r23, Z+1	; 0x01
    1fac:	82 81       	ldd	r24, Z+2	; 0x02
    1fae:	93 81       	ldd	r25, Z+3	; 0x03
    1fb0:	0c 5f       	subi	r16, 0xFC	; 252
    1fb2:	1f 4f       	sbci	r17, 0xFF	; 255
    1fb4:	08 c0       	rjmp	.+16     	; 0x1fc6 <vfprintf+0x206>
    1fb6:	60 81       	ld	r22, Z
    1fb8:	71 81       	ldd	r23, Z+1	; 0x01
    1fba:	88 27       	eor	r24, r24
    1fbc:	77 fd       	sbrc	r23, 7
    1fbe:	80 95       	com	r24
    1fc0:	98 2f       	mov	r25, r24
    1fc2:	0e 5f       	subi	r16, 0xFE	; 254
    1fc4:	1f 4f       	sbci	r17, 0xFF	; 255
    1fc6:	2f 76       	andi	r18, 0x6F	; 111
    1fc8:	b2 2e       	mov	r11, r18
    1fca:	97 ff       	sbrs	r25, 7
    1fcc:	09 c0       	rjmp	.+18     	; 0x1fe0 <vfprintf+0x220>
    1fce:	90 95       	com	r25
    1fd0:	80 95       	com	r24
    1fd2:	70 95       	com	r23
    1fd4:	61 95       	neg	r22
    1fd6:	7f 4f       	sbci	r23, 0xFF	; 255
    1fd8:	8f 4f       	sbci	r24, 0xFF	; 255
    1fda:	9f 4f       	sbci	r25, 0xFF	; 255
    1fdc:	20 68       	ori	r18, 0x80	; 128
    1fde:	b2 2e       	mov	r11, r18
    1fe0:	2a e0       	ldi	r18, 0x0A	; 10
    1fe2:	30 e0       	ldi	r19, 0x00	; 0
    1fe4:	a4 01       	movw	r20, r8
    1fe6:	0e 94 23 11 	call	0x2246	; 0x2246 <__ultoa_invert>
    1fea:	a8 2e       	mov	r10, r24
    1fec:	a8 18       	sub	r10, r8
    1fee:	44 c0       	rjmp	.+136    	; 0x2078 <vfprintf+0x2b8>
    1ff0:	85 37       	cpi	r24, 0x75	; 117
    1ff2:	29 f4       	brne	.+10     	; 0x1ffe <vfprintf+0x23e>
    1ff4:	2f 7e       	andi	r18, 0xEF	; 239
    1ff6:	b2 2e       	mov	r11, r18
    1ff8:	2a e0       	ldi	r18, 0x0A	; 10
    1ffa:	30 e0       	ldi	r19, 0x00	; 0
    1ffc:	25 c0       	rjmp	.+74     	; 0x2048 <vfprintf+0x288>
    1ffe:	f2 2f       	mov	r31, r18
    2000:	f9 7f       	andi	r31, 0xF9	; 249
    2002:	bf 2e       	mov	r11, r31
    2004:	8f 36       	cpi	r24, 0x6F	; 111
    2006:	c1 f0       	breq	.+48     	; 0x2038 <vfprintf+0x278>
    2008:	18 f4       	brcc	.+6      	; 0x2010 <vfprintf+0x250>
    200a:	88 35       	cpi	r24, 0x58	; 88
    200c:	79 f0       	breq	.+30     	; 0x202c <vfprintf+0x26c>
    200e:	b4 c0       	rjmp	.+360    	; 0x2178 <__stack+0x79>
    2010:	80 37       	cpi	r24, 0x70	; 112
    2012:	19 f0       	breq	.+6      	; 0x201a <vfprintf+0x25a>
    2014:	88 37       	cpi	r24, 0x78	; 120
    2016:	21 f0       	breq	.+8      	; 0x2020 <vfprintf+0x260>
    2018:	af c0       	rjmp	.+350    	; 0x2178 <__stack+0x79>
    201a:	2f 2f       	mov	r18, r31
    201c:	20 61       	ori	r18, 0x10	; 16
    201e:	b2 2e       	mov	r11, r18
    2020:	b4 fe       	sbrs	r11, 4
    2022:	0d c0       	rjmp	.+26     	; 0x203e <vfprintf+0x27e>
    2024:	8b 2d       	mov	r24, r11
    2026:	84 60       	ori	r24, 0x04	; 4
    2028:	b8 2e       	mov	r11, r24
    202a:	09 c0       	rjmp	.+18     	; 0x203e <vfprintf+0x27e>
    202c:	24 ff       	sbrs	r18, 4
    202e:	0a c0       	rjmp	.+20     	; 0x2044 <vfprintf+0x284>
    2030:	9f 2f       	mov	r25, r31
    2032:	96 60       	ori	r25, 0x06	; 6
    2034:	b9 2e       	mov	r11, r25
    2036:	06 c0       	rjmp	.+12     	; 0x2044 <vfprintf+0x284>
    2038:	28 e0       	ldi	r18, 0x08	; 8
    203a:	30 e0       	ldi	r19, 0x00	; 0
    203c:	05 c0       	rjmp	.+10     	; 0x2048 <vfprintf+0x288>
    203e:	20 e1       	ldi	r18, 0x10	; 16
    2040:	30 e0       	ldi	r19, 0x00	; 0
    2042:	02 c0       	rjmp	.+4      	; 0x2048 <vfprintf+0x288>
    2044:	20 e1       	ldi	r18, 0x10	; 16
    2046:	32 e0       	ldi	r19, 0x02	; 2
    2048:	f8 01       	movw	r30, r16
    204a:	b7 fe       	sbrs	r11, 7
    204c:	07 c0       	rjmp	.+14     	; 0x205c <vfprintf+0x29c>
    204e:	60 81       	ld	r22, Z
    2050:	71 81       	ldd	r23, Z+1	; 0x01
    2052:	82 81       	ldd	r24, Z+2	; 0x02
    2054:	93 81       	ldd	r25, Z+3	; 0x03
    2056:	0c 5f       	subi	r16, 0xFC	; 252
    2058:	1f 4f       	sbci	r17, 0xFF	; 255
    205a:	06 c0       	rjmp	.+12     	; 0x2068 <vfprintf+0x2a8>
    205c:	60 81       	ld	r22, Z
    205e:	71 81       	ldd	r23, Z+1	; 0x01
    2060:	80 e0       	ldi	r24, 0x00	; 0
    2062:	90 e0       	ldi	r25, 0x00	; 0
    2064:	0e 5f       	subi	r16, 0xFE	; 254
    2066:	1f 4f       	sbci	r17, 0xFF	; 255
    2068:	a4 01       	movw	r20, r8
    206a:	0e 94 23 11 	call	0x2246	; 0x2246 <__ultoa_invert>
    206e:	a8 2e       	mov	r10, r24
    2070:	a8 18       	sub	r10, r8
    2072:	fb 2d       	mov	r31, r11
    2074:	ff 77       	andi	r31, 0x7F	; 127
    2076:	bf 2e       	mov	r11, r31
    2078:	b6 fe       	sbrs	r11, 6
    207a:	0b c0       	rjmp	.+22     	; 0x2092 <vfprintf+0x2d2>
    207c:	2b 2d       	mov	r18, r11
    207e:	2e 7f       	andi	r18, 0xFE	; 254
    2080:	a5 14       	cp	r10, r5
    2082:	50 f4       	brcc	.+20     	; 0x2098 <vfprintf+0x2d8>
    2084:	b4 fe       	sbrs	r11, 4
    2086:	0a c0       	rjmp	.+20     	; 0x209c <vfprintf+0x2dc>
    2088:	b2 fc       	sbrc	r11, 2
    208a:	08 c0       	rjmp	.+16     	; 0x209c <vfprintf+0x2dc>
    208c:	2b 2d       	mov	r18, r11
    208e:	2e 7e       	andi	r18, 0xEE	; 238
    2090:	05 c0       	rjmp	.+10     	; 0x209c <vfprintf+0x2dc>
    2092:	7a 2c       	mov	r7, r10
    2094:	2b 2d       	mov	r18, r11
    2096:	03 c0       	rjmp	.+6      	; 0x209e <vfprintf+0x2de>
    2098:	7a 2c       	mov	r7, r10
    209a:	01 c0       	rjmp	.+2      	; 0x209e <vfprintf+0x2de>
    209c:	75 2c       	mov	r7, r5
    209e:	24 ff       	sbrs	r18, 4
    20a0:	0d c0       	rjmp	.+26     	; 0x20bc <vfprintf+0x2fc>
    20a2:	fe 01       	movw	r30, r28
    20a4:	ea 0d       	add	r30, r10
    20a6:	f1 1d       	adc	r31, r1
    20a8:	80 81       	ld	r24, Z
    20aa:	80 33       	cpi	r24, 0x30	; 48
    20ac:	11 f4       	brne	.+4      	; 0x20b2 <vfprintf+0x2f2>
    20ae:	29 7e       	andi	r18, 0xE9	; 233
    20b0:	09 c0       	rjmp	.+18     	; 0x20c4 <vfprintf+0x304>
    20b2:	22 ff       	sbrs	r18, 2
    20b4:	06 c0       	rjmp	.+12     	; 0x20c2 <vfprintf+0x302>
    20b6:	73 94       	inc	r7
    20b8:	73 94       	inc	r7
    20ba:	04 c0       	rjmp	.+8      	; 0x20c4 <vfprintf+0x304>
    20bc:	82 2f       	mov	r24, r18
    20be:	86 78       	andi	r24, 0x86	; 134
    20c0:	09 f0       	breq	.+2      	; 0x20c4 <vfprintf+0x304>
    20c2:	73 94       	inc	r7
    20c4:	23 fd       	sbrc	r18, 3
    20c6:	13 c0       	rjmp	.+38     	; 0x20ee <vfprintf+0x32e>
    20c8:	20 ff       	sbrs	r18, 0
    20ca:	06 c0       	rjmp	.+12     	; 0x20d8 <vfprintf+0x318>
    20cc:	5a 2c       	mov	r5, r10
    20ce:	73 14       	cp	r7, r3
    20d0:	18 f4       	brcc	.+6      	; 0x20d8 <vfprintf+0x318>
    20d2:	53 0c       	add	r5, r3
    20d4:	57 18       	sub	r5, r7
    20d6:	73 2c       	mov	r7, r3
    20d8:	73 14       	cp	r7, r3
    20da:	68 f4       	brcc	.+26     	; 0x20f6 <vfprintf+0x336>
    20dc:	b7 01       	movw	r22, r14
    20de:	80 e2       	ldi	r24, 0x20	; 32
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	2c 87       	std	Y+12, r18	; 0x0c
    20e4:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <fputc>
    20e8:	73 94       	inc	r7
    20ea:	2c 85       	ldd	r18, Y+12	; 0x0c
    20ec:	f5 cf       	rjmp	.-22     	; 0x20d8 <vfprintf+0x318>
    20ee:	73 14       	cp	r7, r3
    20f0:	10 f4       	brcc	.+4      	; 0x20f6 <vfprintf+0x336>
    20f2:	37 18       	sub	r3, r7
    20f4:	01 c0       	rjmp	.+2      	; 0x20f8 <vfprintf+0x338>
    20f6:	31 2c       	mov	r3, r1
    20f8:	24 ff       	sbrs	r18, 4
    20fa:	12 c0       	rjmp	.+36     	; 0x2120 <__stack+0x21>
    20fc:	b7 01       	movw	r22, r14
    20fe:	80 e3       	ldi	r24, 0x30	; 48
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	2c 87       	std	Y+12, r18	; 0x0c
    2104:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <fputc>
    2108:	2c 85       	ldd	r18, Y+12	; 0x0c
    210a:	22 ff       	sbrs	r18, 2
    210c:	17 c0       	rjmp	.+46     	; 0x213c <__stack+0x3d>
    210e:	21 ff       	sbrs	r18, 1
    2110:	03 c0       	rjmp	.+6      	; 0x2118 <__stack+0x19>
    2112:	88 e5       	ldi	r24, 0x58	; 88
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	02 c0       	rjmp	.+4      	; 0x211c <__stack+0x1d>
    2118:	88 e7       	ldi	r24, 0x78	; 120
    211a:	90 e0       	ldi	r25, 0x00	; 0
    211c:	b7 01       	movw	r22, r14
    211e:	0c c0       	rjmp	.+24     	; 0x2138 <__stack+0x39>
    2120:	82 2f       	mov	r24, r18
    2122:	86 78       	andi	r24, 0x86	; 134
    2124:	59 f0       	breq	.+22     	; 0x213c <__stack+0x3d>
    2126:	21 fd       	sbrc	r18, 1
    2128:	02 c0       	rjmp	.+4      	; 0x212e <__stack+0x2f>
    212a:	80 e2       	ldi	r24, 0x20	; 32
    212c:	01 c0       	rjmp	.+2      	; 0x2130 <__stack+0x31>
    212e:	8b e2       	ldi	r24, 0x2B	; 43
    2130:	27 fd       	sbrc	r18, 7
    2132:	8d e2       	ldi	r24, 0x2D	; 45
    2134:	b7 01       	movw	r22, r14
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <fputc>
    213c:	a5 14       	cp	r10, r5
    213e:	38 f4       	brcc	.+14     	; 0x214e <__stack+0x4f>
    2140:	b7 01       	movw	r22, r14
    2142:	80 e3       	ldi	r24, 0x30	; 48
    2144:	90 e0       	ldi	r25, 0x00	; 0
    2146:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <fputc>
    214a:	5a 94       	dec	r5
    214c:	f7 cf       	rjmp	.-18     	; 0x213c <__stack+0x3d>
    214e:	aa 94       	dec	r10
    2150:	f4 01       	movw	r30, r8
    2152:	ea 0d       	add	r30, r10
    2154:	f1 1d       	adc	r31, r1
    2156:	80 81       	ld	r24, Z
    2158:	b7 01       	movw	r22, r14
    215a:	90 e0       	ldi	r25, 0x00	; 0
    215c:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <fputc>
    2160:	a1 10       	cpse	r10, r1
    2162:	f5 cf       	rjmp	.-22     	; 0x214e <__stack+0x4f>
    2164:	33 20       	and	r3, r3
    2166:	09 f4       	brne	.+2      	; 0x216a <__stack+0x6b>
    2168:	51 ce       	rjmp	.-862    	; 0x1e0c <vfprintf+0x4c>
    216a:	b7 01       	movw	r22, r14
    216c:	80 e2       	ldi	r24, 0x20	; 32
    216e:	90 e0       	ldi	r25, 0x00	; 0
    2170:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <fputc>
    2174:	3a 94       	dec	r3
    2176:	f6 cf       	rjmp	.-20     	; 0x2164 <__stack+0x65>
    2178:	f7 01       	movw	r30, r14
    217a:	86 81       	ldd	r24, Z+6	; 0x06
    217c:	97 81       	ldd	r25, Z+7	; 0x07
    217e:	02 c0       	rjmp	.+4      	; 0x2184 <__stack+0x85>
    2180:	8f ef       	ldi	r24, 0xFF	; 255
    2182:	9f ef       	ldi	r25, 0xFF	; 255
    2184:	2c 96       	adiw	r28, 0x0c	; 12
    2186:	0f b6       	in	r0, 0x3f	; 63
    2188:	f8 94       	cli
    218a:	de bf       	out	0x3e, r29	; 62
    218c:	0f be       	out	0x3f, r0	; 63
    218e:	cd bf       	out	0x3d, r28	; 61
    2190:	df 91       	pop	r29
    2192:	cf 91       	pop	r28
    2194:	1f 91       	pop	r17
    2196:	0f 91       	pop	r16
    2198:	ff 90       	pop	r15
    219a:	ef 90       	pop	r14
    219c:	df 90       	pop	r13
    219e:	cf 90       	pop	r12
    21a0:	bf 90       	pop	r11
    21a2:	af 90       	pop	r10
    21a4:	9f 90       	pop	r9
    21a6:	8f 90       	pop	r8
    21a8:	7f 90       	pop	r7
    21aa:	6f 90       	pop	r6
    21ac:	5f 90       	pop	r5
    21ae:	4f 90       	pop	r4
    21b0:	3f 90       	pop	r3
    21b2:	2f 90       	pop	r2
    21b4:	08 95       	ret

000021b6 <strnlen_P>:
    21b6:	fc 01       	movw	r30, r24
    21b8:	05 90       	lpm	r0, Z+
    21ba:	61 50       	subi	r22, 0x01	; 1
    21bc:	70 40       	sbci	r23, 0x00	; 0
    21be:	01 10       	cpse	r0, r1
    21c0:	d8 f7       	brcc	.-10     	; 0x21b8 <strnlen_P+0x2>
    21c2:	80 95       	com	r24
    21c4:	90 95       	com	r25
    21c6:	8e 0f       	add	r24, r30
    21c8:	9f 1f       	adc	r25, r31
    21ca:	08 95       	ret

000021cc <strnlen>:
    21cc:	fc 01       	movw	r30, r24
    21ce:	61 50       	subi	r22, 0x01	; 1
    21d0:	70 40       	sbci	r23, 0x00	; 0
    21d2:	01 90       	ld	r0, Z+
    21d4:	01 10       	cpse	r0, r1
    21d6:	d8 f7       	brcc	.-10     	; 0x21ce <strnlen+0x2>
    21d8:	80 95       	com	r24
    21da:	90 95       	com	r25
    21dc:	8e 0f       	add	r24, r30
    21de:	9f 1f       	adc	r25, r31
    21e0:	08 95       	ret

000021e2 <fputc>:
    21e2:	0f 93       	push	r16
    21e4:	1f 93       	push	r17
    21e6:	cf 93       	push	r28
    21e8:	df 93       	push	r29
    21ea:	18 2f       	mov	r17, r24
    21ec:	09 2f       	mov	r16, r25
    21ee:	eb 01       	movw	r28, r22
    21f0:	8b 81       	ldd	r24, Y+3	; 0x03
    21f2:	81 fd       	sbrc	r24, 1
    21f4:	03 c0       	rjmp	.+6      	; 0x21fc <fputc+0x1a>
    21f6:	8f ef       	ldi	r24, 0xFF	; 255
    21f8:	9f ef       	ldi	r25, 0xFF	; 255
    21fa:	20 c0       	rjmp	.+64     	; 0x223c <fputc+0x5a>
    21fc:	82 ff       	sbrs	r24, 2
    21fe:	10 c0       	rjmp	.+32     	; 0x2220 <fputc+0x3e>
    2200:	4e 81       	ldd	r20, Y+6	; 0x06
    2202:	5f 81       	ldd	r21, Y+7	; 0x07
    2204:	2c 81       	ldd	r18, Y+4	; 0x04
    2206:	3d 81       	ldd	r19, Y+5	; 0x05
    2208:	42 17       	cp	r20, r18
    220a:	53 07       	cpc	r21, r19
    220c:	7c f4       	brge	.+30     	; 0x222c <fputc+0x4a>
    220e:	e8 81       	ld	r30, Y
    2210:	f9 81       	ldd	r31, Y+1	; 0x01
    2212:	9f 01       	movw	r18, r30
    2214:	2f 5f       	subi	r18, 0xFF	; 255
    2216:	3f 4f       	sbci	r19, 0xFF	; 255
    2218:	39 83       	std	Y+1, r19	; 0x01
    221a:	28 83       	st	Y, r18
    221c:	10 83       	st	Z, r17
    221e:	06 c0       	rjmp	.+12     	; 0x222c <fputc+0x4a>
    2220:	e8 85       	ldd	r30, Y+8	; 0x08
    2222:	f9 85       	ldd	r31, Y+9	; 0x09
    2224:	81 2f       	mov	r24, r17
    2226:	09 95       	icall
    2228:	89 2b       	or	r24, r25
    222a:	29 f7       	brne	.-54     	; 0x21f6 <fputc+0x14>
    222c:	2e 81       	ldd	r18, Y+6	; 0x06
    222e:	3f 81       	ldd	r19, Y+7	; 0x07
    2230:	2f 5f       	subi	r18, 0xFF	; 255
    2232:	3f 4f       	sbci	r19, 0xFF	; 255
    2234:	3f 83       	std	Y+7, r19	; 0x07
    2236:	2e 83       	std	Y+6, r18	; 0x06
    2238:	81 2f       	mov	r24, r17
    223a:	90 2f       	mov	r25, r16
    223c:	df 91       	pop	r29
    223e:	cf 91       	pop	r28
    2240:	1f 91       	pop	r17
    2242:	0f 91       	pop	r16
    2244:	08 95       	ret

00002246 <__ultoa_invert>:
    2246:	fa 01       	movw	r30, r20
    2248:	aa 27       	eor	r26, r26
    224a:	28 30       	cpi	r18, 0x08	; 8
    224c:	51 f1       	breq	.+84     	; 0x22a2 <__ultoa_invert+0x5c>
    224e:	20 31       	cpi	r18, 0x10	; 16
    2250:	81 f1       	breq	.+96     	; 0x22b2 <__ultoa_invert+0x6c>
    2252:	e8 94       	clt
    2254:	6f 93       	push	r22
    2256:	6e 7f       	andi	r22, 0xFE	; 254
    2258:	6e 5f       	subi	r22, 0xFE	; 254
    225a:	7f 4f       	sbci	r23, 0xFF	; 255
    225c:	8f 4f       	sbci	r24, 0xFF	; 255
    225e:	9f 4f       	sbci	r25, 0xFF	; 255
    2260:	af 4f       	sbci	r26, 0xFF	; 255
    2262:	b1 e0       	ldi	r27, 0x01	; 1
    2264:	3e d0       	rcall	.+124    	; 0x22e2 <__ultoa_invert+0x9c>
    2266:	b4 e0       	ldi	r27, 0x04	; 4
    2268:	3c d0       	rcall	.+120    	; 0x22e2 <__ultoa_invert+0x9c>
    226a:	67 0f       	add	r22, r23
    226c:	78 1f       	adc	r23, r24
    226e:	89 1f       	adc	r24, r25
    2270:	9a 1f       	adc	r25, r26
    2272:	a1 1d       	adc	r26, r1
    2274:	68 0f       	add	r22, r24
    2276:	79 1f       	adc	r23, r25
    2278:	8a 1f       	adc	r24, r26
    227a:	91 1d       	adc	r25, r1
    227c:	a1 1d       	adc	r26, r1
    227e:	6a 0f       	add	r22, r26
    2280:	71 1d       	adc	r23, r1
    2282:	81 1d       	adc	r24, r1
    2284:	91 1d       	adc	r25, r1
    2286:	a1 1d       	adc	r26, r1
    2288:	20 d0       	rcall	.+64     	; 0x22ca <__ultoa_invert+0x84>
    228a:	09 f4       	brne	.+2      	; 0x228e <__ultoa_invert+0x48>
    228c:	68 94       	set
    228e:	3f 91       	pop	r19
    2290:	2a e0       	ldi	r18, 0x0A	; 10
    2292:	26 9f       	mul	r18, r22
    2294:	11 24       	eor	r1, r1
    2296:	30 19       	sub	r19, r0
    2298:	30 5d       	subi	r19, 0xD0	; 208
    229a:	31 93       	st	Z+, r19
    229c:	de f6       	brtc	.-74     	; 0x2254 <__ultoa_invert+0xe>
    229e:	cf 01       	movw	r24, r30
    22a0:	08 95       	ret
    22a2:	46 2f       	mov	r20, r22
    22a4:	47 70       	andi	r20, 0x07	; 7
    22a6:	40 5d       	subi	r20, 0xD0	; 208
    22a8:	41 93       	st	Z+, r20
    22aa:	b3 e0       	ldi	r27, 0x03	; 3
    22ac:	0f d0       	rcall	.+30     	; 0x22cc <__ultoa_invert+0x86>
    22ae:	c9 f7       	brne	.-14     	; 0x22a2 <__ultoa_invert+0x5c>
    22b0:	f6 cf       	rjmp	.-20     	; 0x229e <__ultoa_invert+0x58>
    22b2:	46 2f       	mov	r20, r22
    22b4:	4f 70       	andi	r20, 0x0F	; 15
    22b6:	40 5d       	subi	r20, 0xD0	; 208
    22b8:	4a 33       	cpi	r20, 0x3A	; 58
    22ba:	18 f0       	brcs	.+6      	; 0x22c2 <__ultoa_invert+0x7c>
    22bc:	49 5d       	subi	r20, 0xD9	; 217
    22be:	31 fd       	sbrc	r19, 1
    22c0:	40 52       	subi	r20, 0x20	; 32
    22c2:	41 93       	st	Z+, r20
    22c4:	02 d0       	rcall	.+4      	; 0x22ca <__ultoa_invert+0x84>
    22c6:	a9 f7       	brne	.-22     	; 0x22b2 <__ultoa_invert+0x6c>
    22c8:	ea cf       	rjmp	.-44     	; 0x229e <__ultoa_invert+0x58>
    22ca:	b4 e0       	ldi	r27, 0x04	; 4
    22cc:	a6 95       	lsr	r26
    22ce:	97 95       	ror	r25
    22d0:	87 95       	ror	r24
    22d2:	77 95       	ror	r23
    22d4:	67 95       	ror	r22
    22d6:	ba 95       	dec	r27
    22d8:	c9 f7       	brne	.-14     	; 0x22cc <__ultoa_invert+0x86>
    22da:	00 97       	sbiw	r24, 0x00	; 0
    22dc:	61 05       	cpc	r22, r1
    22de:	71 05       	cpc	r23, r1
    22e0:	08 95       	ret
    22e2:	9b 01       	movw	r18, r22
    22e4:	ac 01       	movw	r20, r24
    22e6:	0a 2e       	mov	r0, r26
    22e8:	06 94       	lsr	r0
    22ea:	57 95       	ror	r21
    22ec:	47 95       	ror	r20
    22ee:	37 95       	ror	r19
    22f0:	27 95       	ror	r18
    22f2:	ba 95       	dec	r27
    22f4:	c9 f7       	brne	.-14     	; 0x22e8 <__ultoa_invert+0xa2>
    22f6:	62 0f       	add	r22, r18
    22f8:	73 1f       	adc	r23, r19
    22fa:	84 1f       	adc	r24, r20
    22fc:	95 1f       	adc	r25, r21
    22fe:	a0 1d       	adc	r26, r0
    2300:	08 95       	ret

00002302 <_exit>:
    2302:	f8 94       	cli

00002304 <__stop_program>:
    2304:	ff cf       	rjmp	.-2      	; 0x2304 <__stop_program>
